{
  "language": "Solidity",
  "sources": {
    "contracts/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/BondRedeemer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport { ERC20 } from \"./openzeppelin/ERC20.sol\";\nimport { IERC20 } from \"./openzeppelin/IERC20.sol\";\nimport \"./openzeppelin/Ownable.sol\";\nimport \"./openzeppelin/IOwnable.sol\";\nimport \"./AggregatorV3Interface.sol\";\nimport \"./openzeppelin/SafeERC20.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\ncontract BondRedeemer is Ownable {\n  //Incorrect boilerplate addresses\n  using SafeERC20 for IERC20;\n  address public constant BDAMM = 0xc4F125F56e10980A26093c5ad22AEa1FA93cfd57;\n  address public constant DAMM = 0xD9aA9fD99c2C085ce82A7f084A451C2460FCd73e;\n  address public constant CHAINLINK_DAMM = 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c; //using $LINK Oracle for testing\n  address public admin;\n  bool public redeemAllowed = true;\n\n  mapping(address => bool) public tokensPermitted;\n\n  mapping(address => uint256) public discountRates;\n\n  mapping(address => address) public oracles;\n\n  event Redemption(address redeemer, uint256 quantityOfdAMM, uint256 bdAMMRedeemed, uint256 usdcQuantity);\n  //event TokenPermitted(address token, uint256 discountRates, address oracle);\n  event TokenPermitted(address token, uint256 discountRates, address oracle);\n\n  event NewAdmin(address newAdminAdd);\n\n  constructor() {\n    admin = msg.sender;\n  }\n\n  function dAMMBalance() public view returns (uint256) {\n    uint256 balance = IERC20(DAMM).balanceOf(address(this));\n    return balance;\n  }\n\n  function getLatestPrice(address oracleAdd) public view returns (int256) {\n    AggregatorV3Interface oraclePriceFeed = AggregatorV3Interface(oracleAdd);\n    (\n      ,\n      /*uint80 roundID*/\n      int256 price, /*uint startedAt*/\n      ,\n      ,\n\n    ) = /*uint timeStamp*/\n      /*uint80 answeredInRound*/\n      oraclePriceFeed.latestRoundData();\n    return price;\n  }\n\n  function getLatestDecimals(address oracleAdd) public view returns (uint8) {\n    AggregatorV3Interface oraclePriceFeed = AggregatorV3Interface(oracleAdd);\n    uint8 decimals = oraclePriceFeed.decimals();\n    return decimals;\n  }\n\n  function changeAdmin(address newAdmin) public onlyOwner {\n    require(msg.sender == admin);\n    transferOwnership(newAdmin);\n    emit NewAdmin(newAdmin);\n  }\n\n  // release trapped funds\n  function withdrawTokens(address token) public onlyOwner {\n    require(msg.sender == admin);\n    if (token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n      payable(IOwnable(admin).owner()).transfer(address(this).balance);\n    } else {\n      uint256 balance = IERC20(token).balanceOf(address(this));\n      IERC20(token).transfer(admin, balance);\n    }\n  }\n\n  //Set allowable tokens\n  //Discount rate in BPS\n  //This is the real line, I took out the oracle for testing\n\n  function permitToken(\n    address token,\n    uint256 discountRate,\n    address oracle\n  ) public onlyOwner {\n    require(msg.sender == admin); //double bagging\n    tokensPermitted[token] = true;\n    oracles[token] = oracle;\n    discountRates[token] = discountRate;\n    emit TokenPermitted(token, discountRate, oracle);\n  }\n\n  //Allows the delisting of a bond redemption token\n  function disableToken(address token) public onlyOwner returns (bool) {\n    require(msg.sender == admin);\n    require(tokensPermitted[token] == true, \"Token is not listed\");\n    tokensPermitted[token] = false;\n    return tokensPermitted[token];\n  }\n\n  /**\n   * @notice BONDING REDEMPTIONS\n   * @notice Users can redeem their liquidity bonding tokens for dAMM at a discount to market price\n   * @notice\n   * @param rawbdAMMToRedeem is the quantity of discounted dAMM the user desires to redeem for dAMM\n   * @param paymentToken is the specified redemption token\n   */\n  function BondRedemption(address paymentToken, uint256 rawbdAMMToRedeem) public {\n    require(redeemAllowed == true, \"Liquidity Bonds temporarily disabled.\");\n    require(tokensPermitted[paymentToken] == true, \"Token is not permitted for redemption\");\n\n    uint256 currentBal = dAMMBalance();\n    //current token discount rate\n    uint256 inverseDiscountRateInBPS = 10000 - discountRates[paymentToken];\n\n    //Get latest decimals and token scale\n    uint256 dAMMDecimalScaleUp = 1**(18 - uint256(getLatestDecimals(CHAINLINK_DAMM)));\n    uint256 paymentTokenDecimalScaleUp = 1**(18 - uint256(getLatestDecimals(oracles[paymentToken])));\n\n    //Converting chainlink data to scale\n    uint256 dAMMPriceInUSD = uint256(getLatestPrice(oracles[CHAINLINK_DAMM])) * dAMMDecimalScaleUp;\n    uint256 paymentTokenPrice = uint256(getLatestPrice(oracles[paymentToken])) * paymentTokenDecimalScaleUp;\n\n    //Calculating bdAMM and paymentToken needed, seperated as two variables for clarity\n    uint256 dAMMToReceive = rawbdAMMToRedeem * 1e18;\n    uint256 rawbdAMMConverted = rawbdAMMToRedeem * 1e18;\n\n    uint256 dollarsOfPaymentTokenOwed = (dAMMPriceInUSD * inverseDiscountRateInBPS) / 10000;\n    uint256 paymentTokenOwed = dollarsOfPaymentTokenOwed / paymentTokenPrice;\n\n    //Some extra safety checks\n    require(IERC20(paymentToken).balanceOf(msg.sender) >= paymentTokenOwed);\n    require((currentBal >= dAMMToReceive));\n\n    //msg.sender sends bdAMM to admin, and USDC\n    //for testing removing BDAMM as the ERC20 and using a test ERC20\n    SafeERC20.safeTransferFrom(IERC20(BDAMM), msg.sender, admin, rawbdAMMConverted);\n    SafeERC20.safeTransferFrom(IERC20(paymentToken), msg.sender, admin, paymentTokenOwed);\n    //No reversion because of SafeTransfer above. If either fails minting doesn't occur.\n    //Transfer dAMM to the redeemer\n    SafeERC20.safeTransfer(IERC20(DAMM), msg.sender, dAMMToReceive);\n    emit Redemption(msg.sender, dAMMToReceive, rawbdAMMToRedeem, paymentTokenOwed);\n  }\n}\n"
    },
    "contracts/openzeppelin/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}.\n   *\n   * The default value of {decimals} is 18. To select a different value for\n   * {decimals} you should overload it.\n   *\n   * All two of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint256 totalSupply_,\n    address account\n  ) {\n    _name = name_;\n    _symbol = symbol_;\n    _totalSupply = totalSupply_;\n    _balances[account] = uint256(totalSupply_);\n    emit Transfer(address(0), account, totalSupply_);\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless this function is\n   * overridden;\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address to, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * NOTE: Does not update the allowance if the current allowance\n   * is the maximum `uint256`.\n   *\n   * Requirements:\n   *\n   * - `from` and `to` cannot be the zero address.\n   * - `from` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``from``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n    address owner = _msgSender();\n    uint256 currentAllowance = allowance(owner, spender);\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n    unchecked {\n      _approve(owner, spender, currentAllowance - subtractedValue);\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev Moves `amount` of tokens from `from` to `to`.\n   *\n   * This internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `from` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, amount);\n\n    uint256 fromBalance = _balances[from];\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n      _balances[from] = fromBalance - amount;\n    }\n    _balances[to] += amount;\n\n    emit Transfer(from, to, amount);\n\n    _afterTokenTransfer(from, to, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n    _balances[account] += amount;\n    emit Transfer(address(0), account, amount);\n\n    _afterTokenTransfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n\n    emit Transfer(account, address(0), amount);\n\n    _afterTokenTransfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n   *\n   * Does not update the allowance amount in case of infinite allowance.\n   * Revert if not enough allowance is available.\n   *\n   * Might emit an {Approval} event.\n   */\n  function _spendAllowance(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    uint256 currentAllowance = allowance(owner, spender);\n    if (currentAllowance != type(uint256).max) {\n      require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n      unchecked {\n        _approve(owner, spender, currentAllowance - amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  /**\n   * @dev Hook that is called after any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * has been transferred to `to`.\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n"
    },
    "contracts/openzeppelin/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n}\n"
    },
    "contracts/openzeppelin/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor() {\n    _transferOwnership(_msgSender());\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    _transferOwnership(address(0));\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    _transferOwnership(newOwner);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Internal function without access restriction.\n   */\n  function _transferOwnership(address newOwner) internal virtual {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n  }\n}\n"
    },
    "contracts/openzeppelin/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.11;\n\ninterface IOwnable {\n  function owner() external view returns (address);\n}\n"
    },
    "contracts/openzeppelin/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n   * {IERC20-approve}, and its usage is discouraged.\n   *\n   * Whenever possible, use {safeIncreaseAllowance} and\n   * {safeDecreaseAllowance} instead.\n   */\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require((value == 0) || (token.allowance(address(this), spender) == 0), \"SafeERC20: approve from non-zero to non-zero allowance\");\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    unchecked {\n      uint256 oldAllowance = token.allowance(address(this), spender);\n      require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n      uint256 newAllowance = oldAllowance - value;\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param token The token targeted by the call.\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n"
    },
    "contracts/openzeppelin/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/openzeppelin/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n"
    },
    "contracts/openzeppelin/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{ value: amount }(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    require(isContract(target), \"Address: call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.call{ value: value }(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(isContract(target), \"Address: static call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(isContract(target), \"Address: delegate call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"
    },
    "contracts/openzeppelin/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20.sol\";\nimport \"./Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n  /**\n   * @dev See {ERC20-_beforeTokenTransfer}.\n   *\n   * Requirements:\n   *\n   * - the contract must not be paused.\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override {\n    super._beforeTokenTransfer(from, to, amount);\n\n    require(!paused(), \"ERC20Pausable: token transfer while paused\");\n  }\n}\n"
    },
    "contracts/openzeppelin/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n  /**\n   * @dev Emitted when the pause is triggered by `account`.\n   */\n  event Paused(address account);\n\n  /**\n   * @dev Emitted when the pause is lifted by `account`.\n   */\n  event Unpaused(address account);\n\n  bool private _paused;\n\n  /**\n   * @dev Initializes the contract in unpaused state.\n   */\n  constructor() {\n    _paused = false;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   *\n   * Requirements:\n   *\n   * - The contract must not be paused.\n   */\n  modifier whenNotPaused() {\n    _requireNotPaused();\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   *\n   * Requirements:\n   *\n   * - The contract must be paused.\n   */\n  modifier whenPaused() {\n    _requirePaused();\n    _;\n  }\n\n  /**\n   * @dev Returns true if the contract is paused, and false otherwise.\n   */\n  function paused() public view virtual returns (bool) {\n    return _paused;\n  }\n\n  /**\n   * @dev Throws if the contract is paused.\n   */\n  function _requireNotPaused() internal view virtual {\n    require(!paused(), \"Pausable: paused\");\n  }\n\n  /**\n   * @dev Throws if the contract is not paused.\n   */\n  function _requirePaused() internal view virtual {\n    require(paused(), \"Pausable: not paused\");\n  }\n\n  /**\n   * @dev Triggers stopped state.\n   *\n   * Requirements:\n   *\n   * - The contract must not be paused.\n   */\n  function _pause() internal virtual whenNotPaused {\n    _paused = true;\n    emit Paused(_msgSender());\n  }\n\n  /**\n   * @dev Returns to normal state.\n   *\n   * Requirements:\n   *\n   * - The contract must be paused.\n   */\n  function _unpause() internal virtual whenPaused {\n    _paused = false;\n    emit Unpaused(_msgSender());\n  }\n}\n"
    },
    "contracts/openzeppelin/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"./Context.sol\";\nimport \"./Strings.sol\";\nimport \"./ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n  struct RoleData {\n    mapping(address => bool) members;\n    bytes32 adminRole;\n  }\n\n  mapping(bytes32 => RoleData) private _roles;\n\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n  /**\n   * @dev Modifier that checks that an account has a specific role. Reverts\n   * with a standardized message including the required role.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   *\n   * _Available since v4.1._\n   */\n  modifier onlyRole(bytes32 role) {\n    _checkRole(role);\n    _;\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n    return _roles[role].members[account];\n  }\n\n  /**\n   * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n   * Overriding this function changes the behavior of the {onlyRole} modifier.\n   *\n   * Format of the revert message is described in {_checkRole}.\n   *\n   * _Available since v4.6._\n   */\n  function _checkRole(bytes32 role) internal view virtual {\n    _checkRole(role, _msgSender());\n  }\n\n  /**\n   * @dev Revert with a standard message if `account` is missing `role`.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   */\n  function _checkRole(bytes32 role, address account) internal view virtual {\n    if (!hasRole(role, account)) {\n      revert(\n        string(\n          abi.encodePacked(\"AccessControl: account \", Strings.toHexString(uint160(account), 20), \" is missing role \", Strings.toHexString(uint256(role), 32))\n        )\n      );\n    }\n  }\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n    return _roles[role].adminRole;\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   *\n   * May emit a {RoleGranted} event.\n   */\n  function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   *\n   * May emit a {RoleRevoked} event.\n   */\n  function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been revoked `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   *\n   * May emit a {RoleRevoked} event.\n   */\n  function renounceRole(bytes32 role, address account) public virtual override {\n    require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event. Note that unlike {grantRole}, this function doesn't perform any\n   * checks on the calling account.\n   *\n   * May emit a {RoleGranted} event.\n   *\n   * [WARNING]\n   * ====\n   * This function should only be called from the constructor when setting\n   * up the initial roles for the system.\n   *\n   * Using this function in any other way is effectively circumventing the admin\n   * system imposed by {AccessControl}.\n   * ====\n   *\n   * NOTE: This function is deprecated in favor of {_grantRole}.\n   */\n  function _setupRole(bytes32 role, address account) internal virtual {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Sets `adminRole` as ``role``'s admin role.\n   *\n   * Emits a {RoleAdminChanged} event.\n   */\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n    bytes32 previousAdminRole = getRoleAdmin(role);\n    _roles[role].adminRole = adminRole;\n    emit RoleAdminChanged(role, previousAdminRole, adminRole);\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * Internal function without access restriction.\n   *\n   * May emit a {RoleGranted} event.\n   */\n  function _grantRole(bytes32 role, address account) internal virtual {\n    if (!hasRole(role, account)) {\n      _roles[role].members[account] = true;\n      emit RoleGranted(role, account, _msgSender());\n    }\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * Internal function without access restriction.\n   *\n   * May emit a {RoleRevoked} event.\n   */\n  function _revokeRole(bytes32 role, address account) internal virtual {\n    if (hasRole(role, account)) {\n      _roles[role].members[account] = false;\n      emit RoleRevoked(role, account, _msgSender());\n    }\n  }\n}\n"
    },
    "contracts/openzeppelin/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n  /**\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n   *\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n   * {RoleAdminChanged} not being emitted signaling this.\n   *\n   * _Available since v3.1._\n   */\n  event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n  /**\n   * @dev Emitted when `account` is granted `role`.\n   *\n   * `sender` is the account that originated the contract call, an admin role\n   * bearer except when using {AccessControl-_setupRole}.\n   */\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n  /**\n   * @dev Emitted when `account` is revoked `role`.\n   *\n   * `sender` is the account that originated the contract call:\n   *   - if using `revokeRole`, it is the admin role bearer\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n   */\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/openzeppelin/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n  uint8 private constant _ADDRESS_LENGTH = 20;\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n   */\n  function toHexString(address addr) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n  }\n}\n"
    },
    "contracts/openzeppelin/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "contracts/openzeppelin/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/openzeppelin/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n  /**\n   * @dev Returns one of the accounts that have `role`. `index` must be a\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\n   *\n   * Role bearers are not sorted in any particular way, and their ordering may\n   * change at any point.\n   *\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n   * you perform all queries on the same block. See the following\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n   * for more information.\n   */\n  function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n  /**\n   * @dev Returns the number of accounts that have `role`. Can be used\n   * together with {getRoleMember} to enumerate all bearers of a role.\n   */\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "contracts/openzeppelin/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns one of the accounts that have `role`. `index` must be a\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\n   *\n   * Role bearers are not sorted in any particular way, and their ordering may\n   * change at any point.\n   *\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n   * you perform all queries on the same block. See the following\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n   * for more information.\n   */\n  function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n    return _roleMembers[role].at(index);\n  }\n\n  /**\n   * @dev Returns the number of accounts that have `role`. Can be used\n   * together with {getRoleMember} to enumerate all bearers of a role.\n   */\n  function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n    return _roleMembers[role].length();\n  }\n\n  /**\n   * @dev Overload {_grantRole} to track enumerable memberships\n   */\n  function _grantRole(bytes32 role, address account) internal virtual override {\n    super._grantRole(role, account);\n    _roleMembers[role].add(account);\n  }\n\n  /**\n   * @dev Overload {_revokeRole} to track enumerable memberships\n   */\n  function _revokeRole(bytes32 role, address account) internal virtual override {\n    super._revokeRole(role, account);\n    _roleMembers[role].remove(account);\n  }\n}\n"
    },
    "contracts/openzeppelin/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastValue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastValue;\n        // Update the index for the moved value\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n    return _values(set._inner);\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(AddressSet storage set, address value) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(AddressSet storage set) internal view returns (address[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "contracts/FakeUSDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./openzeppelin/ERC20.sol\";\nimport \"./openzeppelin/ERC20Burnable.sol\";\nimport \"./openzeppelin/ERC20Pausable.sol\";\nimport \"./openzeppelin/AccessControlEnumerable.sol\";\nimport \"./openzeppelin/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract USDC is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  uint256 private _decimals = 6;\n\n  /**\n   * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n   * account that deploys the contract.\n   *\n   * See {ERC20-constructor}.\n   */\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 decimals_\n  ) ERC20(name, symbol, 0, _msgSender()) {\n    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n    _setupRole(MINTER_ROLE, _msgSender());\n    _setupRole(PAUSER_ROLE, _msgSender());\n    _decimals = decimals_;\n  }\n\n  /**\n   * @dev Creates `amount` new tokens for `to`.\n   *\n   * See {ERC20-_mint}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `MINTER_ROLE`.\n   */\n  function mint(address to, uint256 amount) public virtual {\n    require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n    _mint(to, amount);\n  }\n\n  // Hart: Override decimals from ERC20.sol to conform to USDC decimals\n  function decimals() public view override returns (uint8) {\n    return uint8(_decimals);\n  }\n\n  /**\n   * @dev Pauses all token transfers.\n   *\n   * See {ERC20Pausable} and {Pausable-_pause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function pause() public virtual {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n    _pause();\n  }\n\n  /**\n   * @dev Unpauses all token transfers.\n   *\n   * See {ERC20Pausable} and {Pausable-_unpause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function unpause() public virtual {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n    _unpause();\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override(ERC20, ERC20Pausable) {\n    super._beforeTokenTransfer(from, to, amount);\n  }\n}\n"
    },
    "contracts/openzeppelin/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n  /**\n   * @dev Destroys `amount` tokens from the caller.\n   *\n   * See {ERC20-_burn}.\n   */\n  function burn(uint256 amount) public virtual {\n    _burn(_msgSender(), amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n   * allowance.\n   *\n   * See {ERC20-_burn} and {ERC20-allowance}.\n   *\n   * Requirements:\n   *\n   * - the caller must have allowance for ``accounts``'s tokens of at least\n   * `amount`.\n   */\n  function burnFrom(address account, uint256 amount) public virtual {\n    _spendAllowance(account, _msgSender(), amount);\n    _burn(account, amount);\n  }\n}\n"
    },
    "contracts/SimplePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./openzeppelin/Ownable.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./CErc20.sol\";\n\ncontract SimplePriceOracle is PriceOracle, Ownable {\n  mapping(address => uint) prices;\n  event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\n\n  function setDirectPrices(address[] calldata tokens, uint256[] calldata pricesToSet) external onlyOwner {\n    require(tokens.length == pricesToSet.length, \"tokens and prices must have the same length\");\n    for (uint i = 0; i < tokens.length; i ++) {\n      setDirectPrice(tokens[i], pricesToSet[i]);\n    }\n  }\n\n  function _getUnderlyingAddress(CToken cToken) private view returns (address) {\n    address asset;\n    if (compareStrings(cToken.symbol(), \"dETH\")) {\n      asset = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    } else {\n      asset = address(CErc20(address(cToken)).underlying());\n    }\n    return asset;\n  }\n\n  function getUnderlyingPrice(CToken cToken) public override view returns (uint) {\n    return prices[_getUnderlyingAddress(cToken)];\n  }\n\n  function setUnderlyingPrice(CToken cToken, uint underlyingPriceMantissa) public onlyOwner {\n    address asset = _getUnderlyingAddress(cToken);\n    emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\n    prices[asset] = underlyingPriceMantissa;\n  }\n\n  function setDirectPrice(address asset, uint price) public onlyOwner {\n    emit PricePosted(asset, prices[asset], price, price);\n    prices[asset] = price;\n  }\n\n  // v1 price oracle interface for use as backing of proxy\n  function assetPrices(address asset) external view returns (uint) {\n    return prices[asset];\n  }\n\n  function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n}\n"
    },
    "contracts/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CToken.sol\";\n\nabstract contract PriceOracle {\n  /// @notice Indicator that this is a PriceOracle contract (for inspection)\n  bool public constant isPriceOracle = true;\n\n  /**\n   * @notice Get the underlying price of a cToken asset\n   * @param cToken The cToken to get the underlying price of\n   * @return The underlying asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   */\n  function getUnderlyingPrice(CToken cToken) external view virtual returns (uint256);\n}\n"
    },
    "contracts/CErc20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CToken.sol\";\n\ninterface CompLike {\n  function delegate(address delegatee) external;\n}\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ncontract CErc20 is CToken, CErc20Interface {\n  /**\n   * @notice Initialize the new money market\n   * @param underlying_ The address of the underlying asset\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   * @param decimals_ ERC-20 decimal precision of this token\n   */\n  function initialize(\n    address underlying_,\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) public {\n    // CToken initialize does the bulk of the work\n    super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n    // Set underlying and sanity check it\n    underlying = underlying_;\n    EIP20Interface(underlying).totalSupply();\n  }\n\n  /*** User Interface ***/\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function mint(uint256 mintAmount) external override returns (uint256) {\n    mintInternal(mintAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeem(uint256 redeemTokens) external override returns (uint256) {\n    redeemInternal(redeemTokens);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to redeem\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlying(uint256 redeemAmount) external override returns (uint256) {\n    redeemUnderlyingInternal(redeemAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrow(uint256 borrowAmount) external override returns (uint256) {\n    borrowInternal(borrowAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrow(uint256 repayAmount) external override returns (uint256) {\n    repayBorrowInternal(repayAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external override returns (uint256) {\n    repayBorrowBehalfInternal(borrower, repayAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) external override returns (uint256) {\n    liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n   * @param token The address of the ERC-20 token to sweep\n   */\n  function sweepToken(EIP20NonStandardInterface token) external override {\n    require(msg.sender == admin, \"CErc20::sweepToken: only admin can sweep tokens\");\n    require(address(token) != underlying, \"CErc20::sweepToken: can not sweep underlying token\");\n    uint256 balance = token.balanceOf(address(this));\n    token.transfer(admin, balance);\n  }\n\n  /**\n   * @notice The sender adds to reserves.\n   * @param addAmount The amount fo underlying token to add as reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addReserves(uint256 addAmount) external override returns (uint256) {\n    return _addReservesInternal(addAmount);\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying tokens owned by this contract\n   */\n  function getCashPrior() internal view virtual override returns (uint256) {\n    EIP20Interface token = EIP20Interface(underlying);\n    return token.balanceOf(address(this));\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n   *      This will revert due to insufficient balance or insufficient allowance.\n   *      This function returns the actual amount received,\n   *      which may be less than `amount` if there is a fee attached to the transfer.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferIn(address from, uint256 amount) internal virtual override returns (uint256) {\n    // Read from storage once\n    address underlying_ = underlying;\n    EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying_);\n    uint256 balanceBefore = EIP20Interface(underlying_).balanceOf(address(this));\n    token.transferFrom(from, address(this), amount);\n\n    bool success;\n    assembly {\n      switch returndatasize()\n      case 0 {\n        // This is a non-standard ERC-20\n        success := not(0) // set success to true\n      }\n      case 32 {\n        // This is a compliant ERC-20\n        returndatacopy(0, 0, 32)\n        success := mload(0) // Set `success = returndata` of override external call\n      }\n      default {\n        // This is an excessively non-compliant ERC-20, revert.\n        revert(0, 0)\n      }\n    }\n    require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n    // Calculate the amount that was *actually* transferred\n    uint256 balanceAfter = EIP20Interface(underlying_).balanceOf(address(this));\n    return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n   *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n   *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n   *      it is >= amount, this should not revert in normal conditions.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferOut(address payable to, uint256 amount) internal virtual override {\n    EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n    token.transfer(to, amount);\n\n    bool success;\n    assembly {\n      switch returndatasize()\n      case 0 {\n        // This is a non-standard ERC-20\n        success := not(0) // set success to true\n      }\n      case 32 {\n        // This is a compliant ERC-20\n        returndatacopy(0, 0, 32)\n        success := mload(0) // Set `success = returndata` of override external call\n      }\n      default {\n        // This is an excessively non-compliant ERC-20, revert.\n        revert(0, 0)\n      }\n    }\n    require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n  }\n\n  /**\n   * @notice Admin call to delegate the votes of the COMP-like underlying\n   * @param compLikeDelegatee The address to delegate votes to\n   * @dev CTokens whose underlying are not CompLike should revert here\n   */\n  function _delegateCompLikeTo(address compLikeDelegatee) external {\n    require(msg.sender == admin, \"only the admin may set the comp-like delegate\");\n    CompLike(underlying).delegate(compLikeDelegatee);\n  }\n}\n"
    },
    "contracts/CToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\nabstract contract CToken is CTokenInterface, ExponentialNoError, TokenErrorReporter {\n  /**\n   * @notice Initialize the money market\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ EIP-20 name of this token\n   * @param symbol_ EIP-20 symbol of this token\n   * @param decimals_ EIP-20 decimal precision of this token\n   */\n  function initialize(\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) public {\n    require(msg.sender == admin, \"only admin may initialize the market\");\n    require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n    // Set initial exchange rate\n    initialExchangeRateMantissa = initialExchangeRateMantissa_;\n    require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n    // Set the comptroller\n    uint256 err = _setComptroller(comptroller_);\n    require(err == NO_ERROR, \"setting comptroller failed\");\n\n    // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n    accrualBlockNumber = getBlockNumber();\n    borrowIndex = mantissaOne;\n\n    // Set the interest rate model (depends on block number / borrow index)\n    err = _setInterestRateModelFresh(interestRateModel_);\n    require(err == NO_ERROR, \"setting interest rate model failed\");\n\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n\n    // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n    _notEntered = true;\n  }\n\n  /**\n   * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n   * @dev Called by both `transfer` and `transferFrom` internally\n   * @param spender The address of the account performing the transfer\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param tokens The number of tokens to transfer\n   * @return 0 if the transfer succeeded, else revert\n   */\n  function transferTokens(\n    address spender,\n    address src,\n    address dst,\n    uint256 tokens\n  ) internal returns (uint256) {\n    /* Fail if transfer not allowed */\n    uint256 allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n    if (allowed != 0 && spender != admin) {\n      revert TransferComptrollerRejection(allowed);\n    }\n\n    /* Do not allow self-transfers */\n    if (src == dst) {\n      revert TransferNotAllowed();\n    }\n\n    /* Get the allowance, infinite for the account owner */\n    uint256 startingAllowance = 0;\n    if (spender == src || spender == admin) {\n      startingAllowance = type(uint256).max;\n    } else {\n      startingAllowance = transferAllowances[src][spender];\n    }\n\n    /* Do the calculations, checking for {under,over}flow */\n    uint256 allowanceNew = startingAllowance - tokens;\n    uint256 srcTokensNew = accountTokens[src] - tokens;\n    uint256 dstTokensNew = accountTokens[dst] + tokens;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    accountTokens[src] = srcTokensNew;\n    accountTokens[dst] = dstTokensNew;\n\n    /* Eat some of the allowance (if necessary) */\n    if (startingAllowance != type(uint256).max) {\n      transferAllowances[src][spender] = allowanceNew;\n    }\n\n    /* We emit a Transfer event */\n    emit Transfer(src, dst, tokens);\n\n    // unused function\n    // comptroller.transferVerify(address(this), src, dst, tokens);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n    return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external override nonReentrant returns (bool) {\n    return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (uint256.max means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external override returns (bool) {\n    address src = msg.sender;\n    transferAllowances[src][spender] = amount;\n    emit Approval(src, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(address owner, address spender) external view override returns (uint256) {\n    return transferAllowances[owner][spender];\n  }\n\n  /**\n   * @notice Get the token balance of the `owner`\n   * @param owner The address of the account to query\n   * @return The number of tokens owned by `owner`\n   */\n  function balanceOf(address owner) external view override returns (uint256) {\n    return accountTokens[owner];\n  }\n\n  /**\n   * @notice Get the underlying balance of the `owner`\n   * @dev This also accrues interest in a transaction\n   * @param owner The address of the account to query\n   * @return The amount of underlying owned by `owner`\n   */\n  function balanceOfUnderlying(address owner) external override returns (uint256) {\n    Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\n    return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n  }\n\n  /**\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\n   * @dev This is used by comptroller to more efficiently perform liquidity checks.\n   * @param account Address of the account to snapshot\n   * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n   */\n  function getAccountSnapshot(address account)\n    external\n    view\n    override\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    return (NO_ERROR, accountTokens[account], borrowBalanceStoredInternal(account), exchangeRateStoredInternal());\n  }\n\n  /**\n   * @dev Function to simply retrieve block number\n   *  This exists mainly for inheriting test contracts to stub this result.\n   */\n  function getBlockNumber() internal view virtual returns (uint256) {\n    return block.number;\n  }\n\n  /**\n   * @notice Returns the current per-block borrow interest rate for this cToken\n   * @return The borrow interest rate per block, scaled by 1e18\n   */\n  function borrowRatePerBlock() external view override returns (uint256) {\n    return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n  }\n\n  /**\n   * @notice Returns the current per-block supply interest rate for this cToken\n   * @return The supply interest rate per block, scaled by 1e18\n   */\n  function supplyRatePerBlock() external view override returns (uint256) {\n    return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n  }\n\n  /**\n   * @notice Returns the current total borrows plus accrued interest\n   * @return The total borrows with interest\n   */\n  function totalBorrowsCurrent() external override nonReentrant returns (uint256) {\n    accrueInterest();\n    return totalBorrows;\n  }\n\n  /**\n   * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n   * @param account The address whose balance should be calculated after updating borrowIndex\n   * @return The calculated balance\n   */\n  function borrowBalanceCurrent(address account) external override nonReentrant returns (uint256) {\n    accrueInterest();\n    return borrowBalanceStored(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return The calculated balance\n   */\n  function borrowBalanceStored(address account) public view override returns (uint256) {\n    return borrowBalanceStoredInternal(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return (error code, the calculated balance or 0 if error code is non-zero)\n   */\n  function borrowBalanceStoredInternal(address account) internal view returns (uint256) {\n    /* Get borrowBalance and borrowIndex */\n    BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n    /* If borrowBalance = 0 then borrowIndex is likely also 0.\n     * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n     */\n    if (borrowSnapshot.principal == 0) {\n      return 0;\n    }\n\n    /* Calculate new borrow balance using the interest index:\n     *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n     */\n    uint256 principalTimesIndex = borrowSnapshot.principal * borrowIndex;\n    return principalTimesIndex / borrowSnapshot.interestIndex;\n  }\n\n  /**\n   * @notice Accrue interest then return the up-to-date exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateCurrent() public override nonReentrant returns (uint256) {\n    accrueInterest();\n    return exchangeRateStored();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStored() public view override returns (uint256) {\n    return exchangeRateStoredInternal();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStoredInternal() internal view virtual returns (uint256) {\n    uint256 _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n      /*\n       * If there are no tokens minted:\n       *  exchangeRate = initialExchangeRate\n       */\n      return initialExchangeRateMantissa;\n    } else {\n      /*\n       * Otherwise:\n       *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n       */\n      uint256 totalCash = getCashPrior();\n      uint256 cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\n      uint256 exchangeRate = (cashPlusBorrowsMinusReserves * expScale) / _totalSupply;\n\n      return exchangeRate;\n    }\n  }\n\n  /**\n   * @notice Get cash balance of this cToken in the underlying asset\n   * @return The quantity of underlying asset owned by this contract\n   */\n  function getCash() external view override returns (uint256) {\n    return getCashPrior();\n  }\n\n  /**\n   * @notice Applies accrued interest to total borrows and reserves\n   * @dev This calculates interest accrued from the last checkpointed block\n   *   up to the current block and writes new checkpoint to storage.\n   */\n  function accrueInterest() public virtual override returns (uint256) {\n    /* Remember the initial block number */\n    uint256 currentBlockNumber = getBlockNumber();\n    uint256 accrualBlockNumberPrior = accrualBlockNumber;\n\n    /* Short-circuit accumulating 0 interest */\n    if (accrualBlockNumberPrior == currentBlockNumber) {\n      return NO_ERROR;\n    }\n\n    /* Read the previous values out of storage */\n    uint256 cashPrior = getCashPrior();\n    uint256 borrowsPrior = totalBorrows;\n    uint256 reservesPrior = totalReserves;\n    uint256 borrowIndexPrior = borrowIndex;\n\n    /* Calculate the current borrow interest rate */\n    uint256 borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n    require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n    /* Calculate the number of blocks elapsed since the last accrual */\n    uint256 blockDelta = currentBlockNumber - accrualBlockNumberPrior;\n\n    /*\n     * Calculate the interest accumulated into borrows and reserves and the new index:\n     *  simpleInterestFactor = borrowRate * blockDelta\n     *  interestAccumulated = simpleInterestFactor * totalBorrows\n     *  totalBorrowsNew = interestAccumulated + totalBorrows\n     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n     */\n\n    Exp memory simpleInterestFactor = mul_(Exp({ mantissa: borrowRateMantissa }), blockDelta);\n    uint256 interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\n    uint256 totalBorrowsNew = interestAccumulated + borrowsPrior;\n    uint256 totalReservesNew = mul_ScalarTruncateAddUInt(Exp({ mantissa: reserveFactorMantissa }), interestAccumulated, reservesPrior);\n    uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    accrualBlockNumber = currentBlockNumber;\n    borrowIndex = borrowIndexNew;\n    totalBorrows = totalBorrowsNew;\n    totalReserves = totalReservesNew;\n\n    /* We emit an AccrueInterest event */\n    emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   */\n  function mintInternal(uint256 mintAmount) internal nonReentrant {\n    accrueInterest();\n    // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n    mintFresh(msg.sender, mintAmount);\n  }\n\n  /**\n   * @notice User supplies assets into the market and receives cTokens in exchange\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param minter The address of the account which is supplying the assets\n   * @param mintAmount The amount of the underlying asset to supply\n   */\n  function mintFresh(address minter, uint256 mintAmount) internal {\n    /* Fail if mint not allowed */\n    uint256 allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n    if (allowed != 0) {\n      revert MintComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert MintFreshnessCheck();\n    }\n\n    Exp memory exchangeRate = Exp({ mantissa: exchangeRateStoredInternal() });\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     *  We call `doTransferIn` for the minter and the mintAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n     *  side-effects occurred. The function returns the amount actually transferred,\n     *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n     *  of cash.\n     */\n    uint256 actualMintAmount = doTransferIn(minter, mintAmount);\n\n    /*\n     * We get the current exchange rate and calculate the number of cTokens to be minted:\n     *  mintTokens = actualMintAmount / exchangeRate\n     */\n\n    uint256 mintTokens = div_(actualMintAmount, exchangeRate);\n\n    /*\n     * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n     *  totalSupplyNew = totalSupply + mintTokens\n     *  accountTokensNew = accountTokens[minter] + mintTokens\n     * And write them into storage\n     */\n    totalSupply = totalSupply + mintTokens;\n    accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n    /* We emit a Mint event, and a Transfer event */\n    emit Mint(minter, actualMintAmount, mintTokens);\n    emit Transfer(address(this), minter, mintTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   */\n  function redeemInternal(uint256 redeemTokens) internal nonReentrant {\n    accrueInterest();\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    redeemFresh(payable(msg.sender), redeemTokens, 0);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n   */\n  function redeemUnderlyingInternal(uint256 redeemAmount) internal nonReentrant {\n    accrueInterest();\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    redeemFresh(payable(msg.sender), 0, redeemAmount);\n  }\n\n  /**\n   * @notice User redeems cTokens in exchange for the underlying asset\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param redeemer The address of the account which is redeeming the tokens\n   * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   */\n  function redeemFresh(\n    address payable redeemer,\n    uint256 redeemTokensIn,\n    uint256 redeemAmountIn\n  ) internal {\n    require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n    /* exchangeRate = invoke Exchange Rate Stored() */\n    Exp memory exchangeRate = Exp({ mantissa: exchangeRateStoredInternal() });\n\n    uint256 redeemTokens;\n    uint256 redeemAmount;\n    /* If redeemTokensIn > 0: */\n    if (redeemTokensIn > 0) {\n      /*\n       * We calculate the exchange rate and the amount of underlying to be redeemed:\n       *  redeemTokens = redeemTokensIn\n       *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n       */\n      redeemTokens = redeemTokensIn;\n      redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\n    } else {\n      /*\n       * We get the current exchange rate and calculate the amount to be redeemed:\n       *  redeemTokens = redeemAmountIn / exchangeRate\n       *  redeemAmount = redeemAmountIn\n       */\n      redeemTokens = div_(redeemAmountIn, exchangeRate);\n      redeemAmount = redeemAmountIn;\n    }\n\n    /* Fail if redeem not allowed */\n    uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, redeemTokens);\n    if (allowed != 0) {\n      revert RedeemComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert RedeemFreshnessCheck();\n    }\n\n    /* Fail gracefully if protocol has insufficient cash */\n    if (getCashPrior() < redeemAmount) {\n      revert RedeemTransferOutNotPossible();\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We write the previously calculated values into storage.\n     *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\n     */\n    totalSupply = totalSupply - redeemTokens;\n    accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\n\n    /*\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken has redeemAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(redeemer, redeemAmount);\n\n    /* We emit a Transfer event, and a Redeem event */\n    emit Transfer(redeemer, address(this), redeemTokens);\n    emit Redeem(redeemer, redeemAmount, redeemTokens);\n\n    /* We call the defense hook */\n    comptroller.redeemVerify(address(this), redeemer, redeemAmount, redeemTokens);\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   */\n  function borrowInternal(uint256 borrowAmount) internal nonReentrant {\n    accrueInterest();\n    // borrowFresh emits borrow-specific logs on errors, so we don't need to\n    borrowFresh(payable(msg.sender), borrowAmount);\n  }\n\n  /**\n   * @notice Users borrow assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   */\n  function borrowFresh(address payable borrower, uint256 borrowAmount) internal {\n    /* Fail if borrow not allowed */\n    uint256 allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n    if (allowed != 0) {\n      revert BorrowComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert BorrowFreshnessCheck();\n    }\n\n    /* Fail gracefully if protocol has insufficient underlying cash */\n    if (getCashPrior() < borrowAmount) {\n      revert BorrowCashNotAvailable();\n    }\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on overflow:\n     *  accountBorrowNew = accountBorrow + borrowAmount\n     *  totalBorrowsNew = totalBorrows + borrowAmount\n     */\n    uint256 accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n    uint256 accountBorrowsNew = accountBorrowsPrev + borrowAmount;\n    uint256 totalBorrowsNew = totalBorrows + borrowAmount;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\n        `*/\n    accountBorrows[borrower].principal = accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = totalBorrowsNew;\n\n    /*\n     * We invoke doTransferOut for the borrower and the borrowAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken borrowAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(borrower, borrowAmount);\n\n    /* We emit a Borrow event */\n    emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   */\n  function repayBorrowInternal(uint256 repayAmount) internal nonReentrant {\n    accrueInterest();\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   */\n  function repayBorrowBehalfInternal(address borrower, uint256 repayAmount) internal nonReentrant {\n    accrueInterest();\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    repayBorrowFresh(msg.sender, borrower, repayAmount);\n  }\n\n  /**\n   * @notice Borrows are repaid by another user (possibly the borrower).\n   * @param payer the account paying off the borrow\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount the amount of underlying tokens being returned, or -1 for the full outstanding amount\n   * @return (uint) the actual repayment amount.\n   */\n  function repayBorrowFresh(\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) internal returns (uint256) {\n    /* Fail if repayBorrow not allowed */\n    uint256 allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n    if (allowed != 0) {\n      revert RepayBorrowComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert RepayBorrowFreshnessCheck();\n    }\n\n    /* We fetch the amount the borrower owes, with accumulated interest */\n    uint256 accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n\n    /* If repayAmount == -1, repayAmount = accountBorrows */\n    uint256 repayAmountFinal = repayAmount == type(uint256).max ? accountBorrowsPrev : repayAmount;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We call doTransferIn for the payer and the repayAmount\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken holds an additional repayAmount of cash.\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     *   it returns the amount actually transferred, in case of a fee.\n     */\n    uint256 actualRepayAmount = doTransferIn(payer, repayAmountFinal);\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on underflow:\n     *  accountBorrowsNew = accountBorrows - actualRepayAmount\n     *  totalBorrowsNew = totalBorrows - actualRepayAmount\n     */\n    uint256 accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\n    uint256 totalBorrowsNew = totalBorrows - actualRepayAmount;\n\n    /* We write the previously calculated values into storage */\n    accountBorrows[borrower].principal = accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = totalBorrowsNew;\n\n    /* We emit a RepayBorrow event */\n    emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\n\n    return actualRepayAmount;\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   */\n  function liquidateBorrowInternal(\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) internal nonReentrant {\n    require(msg.sender == admin, \"only dAMM Foundation can liquidate borrowers\");\n    accrueInterest();\n    uint256 error = cTokenCollateral.accrueInterest();\n    if (error != NO_ERROR) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n      revert LiquidateAccrueCollateralInterestFailed(error);\n    }\n\n    // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n    liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n  }\n\n  /**\n   * @notice The liquidator liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The lender of this cToken to be liquidated, in the case of dAMM\n   * @param liquidator The address repaying the borrow and seizing collateral\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   */\n  function liquidateBorrowFresh(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) internal {\n    /* Fail if liquidate not allowed */\n    uint256 allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\n    if (allowed != 0) {\n      revert LiquidateComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert LiquidateFreshnessCheck();\n    }\n\n    /* Verify cTokenCollateral market's block number equals current block number */\n    if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n      revert LiquidateCollateralFreshnessCheck();\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      revert LiquidateLiquidatorIsBorrower();\n    }\n\n    /* Fail if repayAmount = 0 */\n    if (repayAmount == 0) {\n      revert LiquidateCloseAmountIsZero();\n    }\n\n    /* Fail if repayAmount = -1 */\n    if (repayAmount == type(uint256).max) {\n      revert LiquidateCloseAmountIsUintMax();\n    }\n\n    /* Fail if repayBorrow fails */\n    uint256 actualRepayAmount = repayBorrowFresh(liquidator, borrower, repayAmount);\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We calculate the number of collateral tokens that will be seized */\n    (uint256 amountSeizeError, uint256 seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);\n    require(amountSeizeError == NO_ERROR, \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n\n    /* Revert if borrower collateral token balance < seizeTokens */\n    require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n\n    // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n    if (address(cTokenCollateral) == address(this)) {\n      seizeInternal(address(this), liquidator, borrower, seizeTokens);\n    } else {\n      require(cTokenCollateral.seize(liquidator, borrower, seizeTokens) == NO_ERROR, \"token seizure failed\");\n    }\n\n    /* We emit a LiquidateBorrow event */\n    emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Will fail unless called by another cToken during the process of liquidation.\n   *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of cTokens to seize\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external override nonReentrant returns (uint256) {\n    seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n   *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n   * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of cTokens to seize\n   */\n  function seizeInternal(\n    address seizerToken,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) internal {\n    /* Fail if seize not allowed */\n    uint256 allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n    if (allowed != 0) {\n      revert LiquidateSeizeComptrollerRejection(allowed);\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      revert LiquidateSeizeLiquidatorIsBorrower();\n    }\n\n    /*\n     * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n     *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n     *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n     */\n    uint256 protocolSeizeTokens = mul_(seizeTokens, Exp({ mantissa: protocolSeizeShareMantissa }));\n    uint256 liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\n    Exp memory exchangeRate = Exp({ mantissa: exchangeRateStoredInternal() });\n    uint256 protocolSeizeAmount = mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);\n    uint256 totalReservesNew = totalReserves + protocolSeizeAmount;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the calculated values into storage */\n    totalReserves = totalReservesNew;\n    totalSupply = totalSupply - protocolSeizeTokens;\n    accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\n    accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;\n\n    /* Emit a Transfer event */\n    emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\n    emit Transfer(borrower, address(this), protocolSeizeTokens);\n    emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @param newPendingAdmin New pending admin.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPendingAdmin(address payable newPendingAdmin) external override returns (uint256) {\n    // Check caller = admin\n    if (msg.sender != admin) {\n      revert SetPendingAdminOwnerCheck();\n    }\n\n    // Save current value, if any, for inclusion in log\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store pendingAdmin with value newPendingAdmin\n    pendingAdmin = newPendingAdmin;\n\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n   * @dev Admin function for pending admin to accept role and update admin\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptAdmin() external override returns (uint256) {\n    // Check caller is pendingAdmin and pendingAdmin  address(0)\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n      revert AcceptAdminPendingAdminCheck();\n    }\n\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store admin with value pendingAdmin\n    admin = pendingAdmin;\n\n    // Clear the pending value\n    pendingAdmin = payable(address(0));\n\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sets a new comptroller for the market\n   * @dev Admin function to set a new comptroller\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setComptroller(ComptrollerInterface newComptroller) public override returns (uint256) {\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert SetComptrollerOwnerCheck();\n    }\n\n    ComptrollerInterface oldComptroller = comptroller;\n    // Ensure invoke comptroller.isComptroller() returns true\n    require(newComptroller.isComptroller(), \"marker method returned false\");\n\n    // Set market's comptroller to newComptroller\n    comptroller = newComptroller;\n\n    // Emit NewComptroller(oldComptroller, newComptroller)\n    emit NewComptroller(oldComptroller, newComptroller);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n   * @dev Admin function to accrue interest and set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external override nonReentrant returns (uint256) {\n    accrueInterest();\n    // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n    return _setReserveFactorFresh(newReserveFactorMantissa);\n  }\n\n  /**\n   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n   * @dev Admin function to set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal returns (uint256) {\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert SetReserveFactorAdminCheck();\n    }\n\n    // Verify market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert SetReserveFactorFreshCheck();\n    }\n\n    // Check newReserveFactor  maxReserveFactor\n    if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n      revert SetReserveFactorBoundsCheck();\n    }\n\n    uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n    reserveFactorMantissa = newReserveFactorMantissa;\n\n    emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring from msg.sender\n   * @param addAmount Amount of addition to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addReservesInternal(uint256 addAmount) internal nonReentrant returns (uint256) {\n    accrueInterest();\n\n    // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n    _addReservesFresh(addAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Add reserves by transferring from caller\n   * @dev Requires fresh interest accrual\n   * @param addAmount Amount of addition to reserves\n   * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\n   */\n  function _addReservesFresh(uint256 addAmount) internal returns (uint256, uint256) {\n    // totalReserves + actualAddAmount\n    uint256 totalReservesNew;\n    uint256 actualAddAmount;\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert AddReservesFactorFreshCheck(actualAddAmount);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We call doTransferIn for the caller and the addAmount\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken holds an additional addAmount of cash.\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     *  it returns the amount actually transferred, in case of a fee.\n     */\n\n    actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n    totalReservesNew = totalReserves + actualAddAmount;\n\n    // Store reserves[n+1] = reserves[n] + actualAddAmount\n    totalReserves = totalReservesNew;\n\n    /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n    emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n    /* Return (NO_ERROR, actualAddAmount) */\n    return (NO_ERROR, actualAddAmount);\n  }\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring to admin\n   * @param reduceAmount Amount of reduction to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _reduceReserves(uint256 reduceAmount) external override nonReentrant returns (uint256) {\n    accrueInterest();\n    // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n    return _reduceReservesFresh(reduceAmount);\n  }\n\n  /**\n   * @notice Reduces reserves by transferring to admin\n   * @dev Requires fresh interest accrual\n   * @param reduceAmount Amount of reduction to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _reduceReservesFresh(uint256 reduceAmount) internal returns (uint256) {\n    // totalReserves - reduceAmount\n    uint256 totalReservesNew;\n\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert ReduceReservesAdminCheck();\n    }\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert ReduceReservesFreshCheck();\n    }\n\n    // Fail gracefully if protocol has insufficient underlying cash\n    if (getCashPrior() < reduceAmount) {\n      revert ReduceReservesCashNotAvailable();\n    }\n\n    // Check reduceAmount  reserves[n] (totalReserves)\n    if (reduceAmount > totalReserves) {\n      revert ReduceReservesCashValidation();\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    totalReservesNew = totalReserves - reduceAmount;\n\n    // Store reserves[n+1] = reserves[n] - reduceAmount\n    totalReserves = totalReservesNew;\n\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n    doTransferOut(admin, reduceAmount);\n\n    emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n   * @dev Admin function to accrue interest and update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) public override returns (uint256) {\n    accrueInterest();\n    // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n    return _setInterestRateModelFresh(newInterestRateModel);\n  }\n\n  /**\n   * @notice updates the interest rate model (*requires fresh interest accrual)\n   * @dev Admin function to update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n    // Used to store old model for use in the event that is emitted on success\n    InterestRateModel oldInterestRateModel;\n\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert SetInterestRateModelOwnerCheck();\n    }\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert SetInterestRateModelFreshCheck();\n    }\n\n    // Track the market's current interest rate model\n    oldInterestRateModel = interestRateModel;\n\n    // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n    require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n    // Set the interest rate model to newInterestRateModel\n    interestRateModel = newInterestRateModel;\n\n    // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n    emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n    return NO_ERROR;\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying owned by this contract\n   */\n  function getCashPrior() internal view virtual returns (uint256);\n\n  /**\n   * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n   *  This may revert due to insufficient balance or insufficient allowance.\n   */\n  function doTransferIn(address from, uint256 amount) internal virtual returns (uint256);\n\n  /**\n   * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\n   *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n   *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n   */\n  function doTransferOut(address payable to, uint256 amount) internal virtual;\n\n  /*** Reentrancy Guard ***/\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   */\n  modifier nonReentrant() {\n    require(_notEntered, \"re-entered\");\n    _notEntered = false;\n    _;\n    _notEntered = true; // get a gas-refund post-Istanbul\n  }\n}\n"
    },
    "contracts/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nabstract contract ComptrollerInterface {\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    bool public constant isComptroller = true;\n\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata cTokens) virtual external returns (uint[] memory);\n    function exitMarket(address cToken) virtual external returns (uint);\n\n    /*** Policy Hooks ***/\n\n    function mintAllowed(address cToken, address minter, uint mintAmount) virtual external returns (uint);\n    function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) virtual external;\n\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) virtual external returns (uint);\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) virtual external;\n\n    function whitelistBorrowerAdd(address borrower) virtual external returns (uint);\n    function setBorrowerLimits(address borrower, uint256 _borrowLimit) virtual external returns (uint);\n    function getBorrowerLimits(address borrower) virtual external returns (uint);\n\n\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) virtual external returns (uint);\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) virtual external;\n\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount) virtual external returns (uint);\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount,\n        uint borrowerIndex) virtual external;\n\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount) virtual external returns (uint);\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        uint seizeTokens) virtual external;\n\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) virtual external returns (uint);\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) virtual external;\n\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) virtual external returns (uint);\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) virtual external;\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint repayAmount) virtual external view returns (uint, uint);\n}\n"
    },
    "contracts/CTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./ErrorReporter.sol\";\n\ncontract CTokenStorage {\n  /**\n   * @dev Guard variable for re-entrancy checks\n   */\n  bool internal _notEntered;\n\n  /**\n   * @notice EIP-20 token name for this token\n   */\n  string public name;\n\n  /**\n   * @notice EIP-20 token symbol for this token\n   */\n  string public symbol;\n\n  /**\n   * @notice EIP-20 token decimals for this token\n   */\n  uint8 public decimals;\n\n  // Maximum borrow rate that can ever be applied (.0005% / block)\n  uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\n\n  // Maximum fraction of interest that can be set aside for reserves\n  uint256 internal constant reserveFactorMaxMantissa = 1e18;\n\n  /**\n   * @notice Administrator for this contract\n   */\n  address payable public admin;\n\n  /**\n   * @notice Pending administrator for this contract\n   */\n  address payable public pendingAdmin;\n\n  /**\n   * @notice Contract which oversees inter-cToken operations\n   */\n  ComptrollerInterface public comptroller;\n\n  /**\n   * @notice Model which tells what the current interest rate should be\n   */\n  InterestRateModel public interestRateModel;\n\n  // Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n  uint256 internal initialExchangeRateMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for reserves\n   */\n  uint256 public reserveFactorMantissa;\n\n  /**\n   * @notice Block number that interest was last accrued at\n   */\n  uint256 public accrualBlockNumber;\n\n  /**\n   * @notice Accumulator of the total earned interest rate since the opening of the market\n   */\n  uint256 public borrowIndex;\n\n  /**\n   * @notice Total amount of outstanding borrows of the underlying in this market\n   */\n  uint256 public totalBorrows;\n\n  /**\n   * @notice Total amount of reserves of the underlying held in this market\n   */\n  uint256 public totalReserves;\n\n  /**\n   * @notice Total number of tokens in circulation\n   */\n  uint256 public totalSupply;\n\n  // Official record of token balances for each account\n  mapping(address => uint256) internal accountTokens;\n\n  // Approved token transfer amounts on behalf of others\n  mapping(address => mapping(address => uint256)) internal transferAllowances;\n\n  /**\n   * @notice Container for borrow balance information\n   * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n   * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n   */\n  struct BorrowSnapshot {\n    uint256 principal;\n    uint256 interestIndex;\n  }\n\n  // Mapping of account addresses to outstanding borrow balances\n  mapping(address => BorrowSnapshot) internal accountBorrows;\n\n  /**\n   * @notice Share of seized collateral that is added to reserves\n   */\n  uint256 public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n}\n\nabstract contract CTokenInterface is CTokenStorage {\n  /**\n   * @notice Indicator that this is a CToken contract (for inspection)\n   */\n  bool public constant isCToken = true;\n\n  /*** Market Events ***/\n\n  /**\n   * @notice Event emitted when interest is accrued\n   */\n  event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndex, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when tokens are minted\n   */\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n\n  /**\n   * @notice Event emitted when tokens are redeemed\n   */\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n\n  /**\n   * @notice Event emitted when underlying is borrowed\n   */\n  event Borrow(address borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is repaid\n   */\n  event RepayBorrow(address payer, address borrower, uint256 repayAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is liquidated\n   */\n  event LiquidateBorrow(address liquidator, address borrower, uint256 repayAmount, address cTokenCollateral, uint256 seizeTokens);\n\n  /*** Admin Events ***/\n\n  /**\n   * @notice Event emitted when pendingAdmin is changed\n   */\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n  /**\n   * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  /**\n   * @notice Event emitted when comptroller is changed\n   */\n  event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n  /**\n   * @notice Event emitted when interestRateModel is changed\n   */\n  event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n  /**\n   * @notice Event emitted when the reserve factor is changed\n   */\n  event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\n\n  /**\n   * @notice Event emitted when the reserves are added\n   */\n  event ReservesAdded(address benefactor, uint256 addAmount, uint256 newTotalReserves);\n\n  /**\n   * @notice Event emitted when the reserves are reduced\n   */\n  event ReservesReduced(address admin, uint256 reduceAmount, uint256 newTotalReserves);\n\n  /**\n   * @notice EIP20 Transfer event\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  /**\n   * @notice EIP20 Approval event\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n  /*** User Interface ***/\n\n  function transfer(address dst, uint256 amount) external virtual returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external virtual returns (bool);\n\n  function approve(address spender, uint256 amount) external virtual returns (bool);\n\n  function allowance(address owner, address spender) external view virtual returns (uint256);\n\n  function balanceOf(address owner) external view virtual returns (uint256);\n\n  function balanceOfUnderlying(address owner) external virtual returns (uint256);\n\n  function getAccountSnapshot(address account)\n    external\n    view\n    virtual\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function borrowRatePerBlock() external view virtual returns (uint256);\n\n  function supplyRatePerBlock() external view virtual returns (uint256);\n\n  function totalBorrowsCurrent() external virtual returns (uint256);\n\n  function borrowBalanceCurrent(address account) external virtual returns (uint256);\n\n  function borrowBalanceStored(address account) external view virtual returns (uint256);\n\n  function exchangeRateCurrent() external virtual returns (uint256);\n\n  function exchangeRateStored() external view virtual returns (uint256);\n\n  function getCash() external view virtual returns (uint256);\n\n  function accrueInterest() external virtual returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external virtual returns (uint256);\n\n  /*** Admin Functions ***/\n\n  function _setPendingAdmin(address payable newPendingAdmin) external virtual returns (uint256);\n\n  function _acceptAdmin() external virtual returns (uint256);\n\n  function _setComptroller(ComptrollerInterface newComptroller) external virtual returns (uint256);\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external virtual returns (uint256);\n\n  function _reduceReserves(uint256 reduceAmount) external virtual returns (uint256);\n\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) external virtual returns (uint256);\n}\n\ncontract CErc20Storage {\n  /**\n   * @notice Underlying asset for this CToken\n   */\n  address public underlying;\n}\n\nabstract contract CErc20Interface is CErc20Storage {\n  /*** User Interface ***/\n\n  function mint(uint256 mintAmount) external virtual returns (uint256);\n\n  function redeem(uint256 redeemTokens) external virtual returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);\n\n  function borrow(uint256 borrowAmount) external virtual returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external virtual returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (uint256);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) external virtual returns (uint256);\n\n  function sweepToken(EIP20NonStandardInterface token) external virtual;\n\n  /*** Admin Functions ***/\n\n  function _addReserves(uint256 addAmount) external virtual returns (uint256);\n}\n\ncontract CDelegationStorage {\n  /**\n   * @notice Implementation address for this contract\n   */\n  address public implementation;\n}\n\nabstract contract CDelegatorInterface is CDelegationStorage {\n  /**\n   * @notice Emitted when implementation is changed\n   */\n  event NewImplementation(address oldImplementation, address newImplementation);\n\n  /**\n   * @notice Called by the admin to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n   */\n  function _setImplementation(\n    address implementation_,\n    bool allowResign,\n    bytes memory becomeImplementationData\n  ) external virtual;\n}\n\nabstract contract CDelegateInterface is CDelegationStorage {\n  /**\n   * @notice Called by the delegator on a delegate to initialize it for duty\n   * @dev Should revert if any issues arise which make it unfit for delegation\n   * @param data The encoded bytes data for any initialization\n   */\n  function _becomeImplementation(bytes memory data) external virtual;\n\n  /**\n   * @notice Called by the delegator on a delegate to forfeit its responsibility\n   */\n  function _resignImplementation() external virtual;\n}\n"
    },
    "contracts/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ncontract ComptrollerErrorReporter {\n  enum Error {\n    NO_ERROR,\n    UNAUTHORIZED,\n    COMPTROLLER_MISMATCH,\n    INSUFFICIENT_SHORTFALL,\n    INSUFFICIENT_LIQUIDITY,\n    INVALID_CLOSE_FACTOR,\n    INVALID_COLLATERAL_FACTOR,\n    INVALID_LIQUIDATION_INCENTIVE,\n    MARKET_NOT_ENTERED, // no longer possible\n    MARKET_NOT_LISTED,\n    MARKET_ALREADY_LISTED,\n    MATH_ERROR,\n    NONZERO_BORROW_BALANCE,\n    PRICE_ERROR,\n    REJECTION,\n    SNAPSHOT_ERROR,\n    TOO_MANY_ASSETS,\n    TOO_MUCH_REPAY\n  }\n\n  enum FailureInfo {\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n    ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n    EXIT_MARKET_BALANCE_OWED,\n    EXIT_MARKET_REJECTION,\n    SET_CLOSE_FACTOR_OWNER_CHECK,\n    SET_CLOSE_FACTOR_VALIDATION,\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\n    SET_COLLATERAL_FACTOR_NO_EXISTS,\n    SET_COLLATERAL_FACTOR_VALIDATION,\n    SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n    SET_IMPLEMENTATION_OWNER_CHECK,\n    SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n    SET_LIQUIDATION_INCENTIVE_VALIDATION,\n    SET_MAX_ASSETS_OWNER_CHECK,\n    SET_PENDING_ADMIN_OWNER_CHECK,\n    SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n    SET_PRICE_ORACLE_OWNER_CHECK,\n    SUPPORT_MARKET_EXISTS,\n    SUPPORT_MARKET_OWNER_CHECK,\n    SET_PAUSE_GUARDIAN_OWNER_CHECK,\n    SET_BORROWER_LIMIT_CHECK\n  }\n\n  /**\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n   **/\n  event Failure(uint256 error, uint256 info, uint256 detail);\n\n  /**\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n   */\n  function fail(Error err, FailureInfo info) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), 0);\n\n    return uint256(err);\n  }\n\n  /**\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n   */\n  function failOpaque(\n    Error err,\n    FailureInfo info,\n    uint256 opaqueError\n  ) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), opaqueError);\n\n    return uint256(err);\n  }\n}\n\ncontract TokenErrorReporter {\n  uint256 public constant NO_ERROR = 0; // support legacy return codes\n\n  error TransferComptrollerRejection(uint256 errorCode);\n  error TransferNotAllowed();\n  error TransferNotEnough();\n  error TransferTooMuch();\n\n  error MintComptrollerRejection(uint256 errorCode);\n  error MintFreshnessCheck();\n\n  error RedeemComptrollerRejection(uint256 errorCode);\n  error RedeemFreshnessCheck();\n  error RedeemTransferOutNotPossible();\n\n  error BorrowComptrollerRejection(uint256 errorCode);\n  error BorrowFreshnessCheck();\n  error BorrowCashNotAvailable();\n\n  error RepayBorrowComptrollerRejection(uint256 errorCode);\n  error RepayBorrowFreshnessCheck();\n\n  error LiquidateComptrollerRejection(uint256 errorCode);\n  error LiquidateFreshnessCheck();\n  error LiquidateCollateralFreshnessCheck();\n  error LiquidateAccrueBorrowInterestFailed(uint256 errorCode);\n  error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);\n  error LiquidateLiquidatorIsBorrower();\n  error LiquidateCloseAmountIsZero();\n  error LiquidateCloseAmountIsUintMax();\n  error LiquidateRepayBorrowFreshFailed(uint256 errorCode);\n\n  error LiquidateSeizeComptrollerRejection(uint256 errorCode);\n  error LiquidateSeizeLiquidatorIsBorrower();\n\n  error AcceptAdminPendingAdminCheck();\n\n  error SetComptrollerOwnerCheck();\n  error SetPendingAdminOwnerCheck();\n\n  error SetReserveFactorAdminCheck();\n  error SetReserveFactorFreshCheck();\n  error SetReserveFactorBoundsCheck();\n\n  error AddReservesFactorFreshCheck(uint256 actualAddAmount);\n\n  error ReduceReservesAdminCheck();\n  error ReduceReservesFreshCheck();\n  error ReduceReservesCashNotAvailable();\n  error ReduceReservesCashValidation();\n\n  error SetInterestRateModelOwnerCheck();\n  error SetInterestRateModelFreshCheck();\n}\n"
    },
    "contracts/EIP20Interface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title ERC 20 Token Standard Interface\n *  https://eips.ethereum.org/EIPS/eip-20\n */\ninterface EIP20Interface {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  /**\n   * @notice Get the total number of tokens in circulation\n   * @return The supply of tokens\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Gets the balance of the specified address\n   * @param owner The address from which the balance will be retrieved\n   * @return balance The balance\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return success Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 amount) external returns (bool success);\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return success Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool success);\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (-1 means infinite)\n   * @return success Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external returns (bool success);\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return remaining The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title Compound's InterestRateModel Interface\n * @author Compound\n */\nabstract contract InterestRateModel {\n  /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n  bool public constant isInterestRateModel = true;\n\n  /**\n   * @notice Calculates the current borrow interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amount of reserves the market has\n   * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) external view virtual returns (uint256);\n\n  /**\n   * @notice Calculates the current supply interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amount of reserves the market has\n   * @param reserveFactorMantissa The current reserve factor the market has\n   * @return The supply rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) external view virtual returns (uint256);\n}\n"
    },
    "contracts/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n  uint256 constant expScale = 1e18;\n  uint256 constant doubleScale = 1e36;\n  uint256 constant halfExpScale = expScale / 2;\n  uint256 constant mantissaOne = expScale;\n\n  struct Exp {\n    uint256 mantissa;\n  }\n\n  struct Double {\n    uint256 mantissa;\n  }\n\n  /**\n   * @dev Truncates the given exp to a whole number value.\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n   */\n  function truncate(Exp memory exp) internal pure returns (uint256) {\n    // Note: We are not using careful math here as we're performing a division that cannot fail\n    return exp.mantissa / expScale;\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\n    Exp memory product = mul_(a, scalar);\n    return truncate(product);\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mul_ScalarTruncateAddUInt(\n    Exp memory a,\n    uint256 scalar,\n    uint256 addend\n  ) internal pure returns (uint256) {\n    Exp memory product = mul_(a, scalar);\n    return add_(truncate(product), addend);\n  }\n\n  /**\n   * @dev Checks if first Exp is less than second Exp.\n   */\n  function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa < right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp <= right Exp.\n   */\n  function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa <= right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp > right Exp.\n   */\n  function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa > right.mantissa;\n  }\n\n  /**\n   * @dev returns true if Exp is exactly zero\n   */\n  function isZeroExp(Exp memory value) internal pure returns (bool) {\n    return value.mantissa == 0;\n  }\n\n  function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\n    require(n < 2**224, errorMessage);\n    return uint224(n);\n  }\n\n  function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: add_(a.mantissa, b.mantissa) });\n  }\n\n  function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: add_(a.mantissa, b.mantissa) });\n  }\n\n  function add_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a + b;\n  }\n\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: sub_(a.mantissa, b.mantissa) });\n  }\n\n  function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: sub_(a.mantissa, b.mantissa) });\n  }\n\n  function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a - b;\n  }\n\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: mul_(a.mantissa, b.mantissa) / expScale });\n  }\n\n  function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: mul_(a.mantissa, b) });\n  }\n\n  function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\n    return mul_(a, b.mantissa) / expScale;\n  }\n\n  function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: mul_(a.mantissa, b.mantissa) / doubleScale });\n  }\n\n  function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: mul_(a.mantissa, b) });\n  }\n\n  function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\n    return mul_(a, b.mantissa) / doubleScale;\n  }\n\n  function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a * b;\n  }\n\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: div_(mul_(a.mantissa, expScale), b.mantissa) });\n  }\n\n  function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: div_(a.mantissa, b) });\n  }\n\n  function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\n    return div_(mul_(a, expScale), b.mantissa);\n  }\n\n  function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa) });\n  }\n\n  function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(a.mantissa, b) });\n  }\n\n  function div_(uint256 a, Double memory b) internal pure returns (uint256) {\n    return div_(mul_(a, doubleScale), b.mantissa);\n  }\n\n  function div_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(mul_(a, doubleScale), b) });\n  }\n}\n"
    },
    "contracts/EIP20NonStandardInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ninterface EIP20NonStandardInterface {\n  /**\n   * @notice Get the total number of tokens in circulation\n   * @return The supply of tokens\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Gets the balance of the specified address\n   * @param owner The address from which the balance will be retrieved\n   * @return balance The balance\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  ///\n  /// !!!!!!!!!!!!!!\n  /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n  /// !!!!!!!!!!!!!!\n  ///\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   */\n  function transfer(address dst, uint256 amount) external;\n\n  ///\n  /// !!!!!!!!!!!!!!\n  /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n  /// !!!!!!!!!!!!!!\n  ///\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved\n   * @return success Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external returns (bool success);\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return remaining The number of tokens allowed to be spent\n   */\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/Lens/CompoundLens.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"../CErc20.sol\";\nimport \"../CToken.sol\";\nimport \"../PriceOracle.sol\";\nimport \"../EIP20Interface.sol\";\nimport \"../Governance/GovernorAlpha.sol\";\nimport \"../Governance/Comp.sol\";\n\ninterface ComptrollerLensInterface {\n  function markets(address) external view returns (bool, uint256);\n\n  function oracle() external view returns (PriceOracle);\n\n  function getAccountLiquidity(address)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function getAssetsIn(address) external view returns (CToken[] memory);\n\n  function claimComp(address) external;\n\n  function compAccrued(address) external view returns (uint256);\n\n  function compSpeeds(address) external view returns (uint256);\n\n  function compSupplySpeeds(address) external view returns (uint256);\n\n  function compBorrowSpeeds(address) external view returns (uint256);\n\n  function borrowCaps(address) external view returns (uint256);\n}\n\ninterface ComptrollerLens2Interface {\n  function claimComp(address[] memory, CToken[] memory, bool, bool) external;\n\n  function compAccrued(address) external view returns (uint256);\n}\n\ninterface GovernorBravoInterface {\n  struct Receipt {\n    bool hasVoted;\n    uint8 support;\n    uint96 votes;\n  }\n  struct Proposal {\n    uint256 id;\n    address proposer;\n    uint256 eta;\n    uint256 startBlock;\n    uint256 endBlock;\n    uint256 forVotes;\n    uint256 againstVotes;\n    uint256 abstainVotes;\n    bool canceled;\n    bool executed;\n  }\n\n  function getActions(uint256 proposalId)\n    external\n    view\n    returns (\n      address[] memory targets,\n      uint256[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    );\n\n  function proposals(uint256 proposalId) external view returns (Proposal memory);\n\n  function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory);\n}\n\ncontract CompoundLens {\n  struct CTokenMetadata {\n    address cToken;\n    uint256 exchangeRateCurrent;\n    uint256 supplyRatePerBlock;\n    uint256 borrowRatePerBlock;\n    uint256 reserveFactorMantissa;\n    uint256 totalBorrows;\n    uint256 totalReserves;\n    uint256 totalSupply;\n    uint256 totalCash;\n    bool isListed;\n    uint256 collateralFactorMantissa;\n    address underlyingAssetAddress;\n    uint256 cTokenDecimals;\n    uint256 underlyingDecimals;\n    uint256 compSupplySpeed;\n    uint256 compBorrowSpeed;\n    uint256 borrowCap;\n  }\n\n  function getCompSpeeds(ComptrollerLensInterface comptroller, CToken cToken) internal returns (uint256, uint256) {\n    // Getting comp speeds is gnarly due to not every network having the\n    // split comp speeds from Proposal 62 and other networks don't even\n    // have comp speeds.\n    uint256 compSupplySpeed = 0;\n    (bool compSupplySpeedSuccess, bytes memory compSupplySpeedReturnData) = address(comptroller).call(\n      abi.encodePacked(comptroller.compSupplySpeeds.selector, abi.encode(address(cToken)))\n    );\n    if (compSupplySpeedSuccess) {\n      compSupplySpeed = abi.decode(compSupplySpeedReturnData, (uint256));\n    }\n\n    uint256 compBorrowSpeed = 0;\n    (bool compBorrowSpeedSuccess, bytes memory compBorrowSpeedReturnData) = address(comptroller).call(\n      abi.encodePacked(comptroller.compBorrowSpeeds.selector, abi.encode(address(cToken)))\n    );\n    if (compBorrowSpeedSuccess) {\n      compBorrowSpeed = abi.decode(compBorrowSpeedReturnData, (uint256));\n    }\n\n    // If the split comp speeds call doesn't work, try the  oldest non-spit version.\n    if (!compSupplySpeedSuccess || !compBorrowSpeedSuccess) {\n      (bool compSpeedSuccess, bytes memory compSpeedReturnData) = address(comptroller).call(\n        abi.encodePacked(comptroller.compSpeeds.selector, abi.encode(address(cToken)))\n      );\n      if (compSpeedSuccess) {\n        compSupplySpeed = compBorrowSpeed = abi.decode(compSpeedReturnData, (uint256));\n      }\n    }\n    return (compSupplySpeed, compBorrowSpeed);\n  }\n\n  function cTokenMetadata(CToken cToken) public returns (CTokenMetadata memory) {\n    uint256 exchangeRateCurrent = cToken.exchangeRateCurrent();\n    ComptrollerLensInterface comptroller = ComptrollerLensInterface(address(cToken.comptroller()));\n    (bool isListed, uint256 collateralFactorMantissa) = comptroller.markets(address(cToken));\n    address underlyingAssetAddress;\n    uint256 underlyingDecimals;\n\n    if (compareStrings(cToken.symbol(), \"dETH\")) {\n      underlyingAssetAddress = address(0);\n      underlyingDecimals = 18;\n    } else {\n      CErc20 cErc20 = CErc20(address(cToken));\n      underlyingAssetAddress = cErc20.underlying();\n      underlyingDecimals = EIP20Interface(cErc20.underlying()).decimals();\n    }\n\n    (uint256 compSupplySpeed, uint256 compBorrowSpeed) = getCompSpeeds(comptroller, cToken);\n\n    uint256 borrowCap = 0;\n    (bool borrowCapSuccess, bytes memory borrowCapReturnData) = address(comptroller).call(\n      abi.encodePacked(comptroller.borrowCaps.selector, abi.encode(address(cToken)))\n    );\n    if (borrowCapSuccess) {\n      borrowCap = abi.decode(borrowCapReturnData, (uint256));\n    }\n\n    return\n      CTokenMetadata({\n        cToken: address(cToken),\n        exchangeRateCurrent: exchangeRateCurrent,\n        supplyRatePerBlock: cToken.supplyRatePerBlock(),\n        borrowRatePerBlock: cToken.borrowRatePerBlock(),\n        reserveFactorMantissa: cToken.reserveFactorMantissa(),\n        totalBorrows: cToken.totalBorrows(),\n        totalReserves: cToken.totalReserves(),\n        totalSupply: cToken.totalSupply(),\n        totalCash: cToken.getCash(),\n        isListed: isListed,\n        collateralFactorMantissa: collateralFactorMantissa,\n        underlyingAssetAddress: underlyingAssetAddress,\n        cTokenDecimals: cToken.decimals(),\n        underlyingDecimals: underlyingDecimals,\n        compSupplySpeed: compSupplySpeed,\n        compBorrowSpeed: compBorrowSpeed,\n        borrowCap: borrowCap\n      });\n  }\n\n  function cTokenMetadataAll(CToken[] calldata cTokens) external returns (CTokenMetadata[] memory) {\n    uint256 cTokenCount = cTokens.length;\n    CTokenMetadata[] memory res = new CTokenMetadata[](cTokenCount);\n    for (uint256 i = 0; i < cTokenCount; i++) {\n      res[i] = cTokenMetadata(cTokens[i]);\n    }\n    return res;\n  }\n\n  struct CTokenBalances {\n    address cToken;\n    uint256 balanceOf;\n    uint256 borrowBalanceCurrent;\n    uint256 balanceOfUnderlying;\n    uint256 tokenBalance;\n    uint256 tokenAllowance;\n  }\n\n  function cTokenBalances(CToken cToken, address payable account) public returns (CTokenBalances memory) {\n    uint256 balanceOf = cToken.balanceOf(account);\n    uint256 borrowBalanceCurrent = cToken.borrowBalanceCurrent(account);\n    uint256 balanceOfUnderlying = cToken.balanceOfUnderlying(account);\n    uint256 tokenBalance;\n    uint256 tokenAllowance;\n\n    if (compareStrings(cToken.symbol(), \"dETH\")) {\n      tokenBalance = account.balance;\n      tokenAllowance = account.balance;\n    } else {\n      CErc20 cErc20 = CErc20(address(cToken));\n      EIP20Interface underlying = EIP20Interface(cErc20.underlying());\n      tokenBalance = underlying.balanceOf(account);\n      tokenAllowance = underlying.allowance(account, address(cToken));\n    }\n\n    return\n      CTokenBalances({\n        cToken: address(cToken),\n        balanceOf: balanceOf,\n        borrowBalanceCurrent: borrowBalanceCurrent,\n        balanceOfUnderlying: balanceOfUnderlying,\n        tokenBalance: tokenBalance,\n        tokenAllowance: tokenAllowance\n      });\n  }\n\n  function cTokenBalancesAll(CToken[] calldata cTokens, address payable account) external returns (CTokenBalances[] memory) {\n    uint256 cTokenCount = cTokens.length;\n    CTokenBalances[] memory res = new CTokenBalances[](cTokenCount);\n    for (uint256 i = 0; i < cTokenCount; i++) {\n      res[i] = cTokenBalances(cTokens[i], account);\n    }\n    return res;\n  }\n\n  struct CTokenUnderlyingPrice {\n    address cToken;\n    uint256 underlyingPrice;\n  }\n\n  function cTokenUnderlyingPrice(CToken cToken) public returns (CTokenUnderlyingPrice memory) {\n    ComptrollerLensInterface comptroller = ComptrollerLensInterface(address(cToken.comptroller()));\n    PriceOracle priceOracle = comptroller.oracle();\n\n    return CTokenUnderlyingPrice({ cToken: address(cToken), underlyingPrice: priceOracle.getUnderlyingPrice(cToken) });\n  }\n\n  function cTokenUnderlyingPriceAll(CToken[] calldata cTokens) external returns (CTokenUnderlyingPrice[] memory) {\n    uint256 cTokenCount = cTokens.length;\n    CTokenUnderlyingPrice[] memory res = new CTokenUnderlyingPrice[](cTokenCount);\n    for (uint256 i = 0; i < cTokenCount; i++) {\n      res[i] = cTokenUnderlyingPrice(cTokens[i]);\n    }\n    return res;\n  }\n\n  struct AccountLimits {\n    CToken[] markets;\n    uint256 liquidity;\n    uint256 shortfall;\n  }\n\n  function getAccountLimits(ComptrollerLensInterface comptroller, address account) public returns (AccountLimits memory) {\n    (uint256 errorCode, uint256 liquidity, uint256 shortfall) = comptroller.getAccountLiquidity(account);\n    require(errorCode == 0);\n\n    return AccountLimits({ markets: comptroller.getAssetsIn(account), liquidity: liquidity, shortfall: shortfall });\n  }\n\n  struct GovReceipt {\n    uint256 proposalId;\n    bool hasVoted;\n    bool support;\n    uint96 votes;\n  }\n\n  function getGovReceipts(\n    GovernorAlpha governor,\n    address voter,\n    uint256[] memory proposalIds\n  ) public view returns (GovReceipt[] memory) {\n    uint256 proposalCount = proposalIds.length;\n    GovReceipt[] memory res = new GovReceipt[](proposalCount);\n    for (uint256 i = 0; i < proposalCount; i++) {\n      GovernorAlpha.Receipt memory receipt = governor.getReceipt(proposalIds[i], voter);\n      res[i] = GovReceipt({ proposalId: proposalIds[i], hasVoted: receipt.hasVoted, support: receipt.support, votes: receipt.votes });\n    }\n    return res;\n  }\n\n  struct GovBravoReceipt {\n    uint256 proposalId;\n    bool hasVoted;\n    uint8 support;\n    uint96 votes;\n  }\n\n  function getGovBravoReceipts(\n    GovernorBravoInterface governor,\n    address voter,\n    uint256[] memory proposalIds\n  ) public view returns (GovBravoReceipt[] memory) {\n    uint256 proposalCount = proposalIds.length;\n    GovBravoReceipt[] memory res = new GovBravoReceipt[](proposalCount);\n    for (uint256 i = 0; i < proposalCount; i++) {\n      GovernorBravoInterface.Receipt memory receipt = governor.getReceipt(proposalIds[i], voter);\n      res[i] = GovBravoReceipt({ proposalId: proposalIds[i], hasVoted: receipt.hasVoted, support: receipt.support, votes: receipt.votes });\n    }\n    return res;\n  }\n\n  struct GovProposal {\n    uint256 proposalId;\n    address proposer;\n    uint256 eta;\n    address[] targets;\n    uint256[] values;\n    string[] signatures;\n    bytes[] calldatas;\n    uint256 startBlock;\n    uint256 endBlock;\n    uint256 forVotes;\n    uint256 againstVotes;\n    bool canceled;\n    bool executed;\n  }\n\n  function setProposal(\n    GovProposal memory res,\n    GovernorAlpha governor,\n    uint256 proposalId\n  ) internal view {\n    (, address proposer, uint256 eta, uint256 startBlock, uint256 endBlock, uint256 forVotes, uint256 againstVotes, bool canceled, bool executed) = governor\n      .proposals(proposalId);\n    res.proposalId = proposalId;\n    res.proposer = proposer;\n    res.eta = eta;\n    res.startBlock = startBlock;\n    res.endBlock = endBlock;\n    res.forVotes = forVotes;\n    res.againstVotes = againstVotes;\n    res.canceled = canceled;\n    res.executed = executed;\n  }\n\n  function getGovProposals(GovernorAlpha governor, uint256[] calldata proposalIds) external view returns (GovProposal[] memory) {\n    GovProposal[] memory res = new GovProposal[](proposalIds.length);\n    for (uint256 i = 0; i < proposalIds.length; i++) {\n      (address[] memory targets, uint256[] memory values, string[] memory signatures, bytes[] memory calldatas) = governor.getActions(proposalIds[i]);\n      res[i] = GovProposal({\n        proposalId: 0,\n        proposer: address(0),\n        eta: 0,\n        targets: targets,\n        values: values,\n        signatures: signatures,\n        calldatas: calldatas,\n        startBlock: 0,\n        endBlock: 0,\n        forVotes: 0,\n        againstVotes: 0,\n        canceled: false,\n        executed: false\n      });\n      setProposal(res[i], governor, proposalIds[i]);\n    }\n    return res;\n  }\n\n  struct GovBravoProposal {\n    uint256 proposalId;\n    address proposer;\n    uint256 eta;\n    address[] targets;\n    uint256[] values;\n    string[] signatures;\n    bytes[] calldatas;\n    uint256 startBlock;\n    uint256 endBlock;\n    uint256 forVotes;\n    uint256 againstVotes;\n    uint256 abstainVotes;\n    bool canceled;\n    bool executed;\n  }\n\n  function setBravoProposal(\n    GovBravoProposal memory res,\n    GovernorBravoInterface governor,\n    uint256 proposalId\n  ) internal view {\n    GovernorBravoInterface.Proposal memory p = governor.proposals(proposalId);\n\n    res.proposalId = proposalId;\n    res.proposer = p.proposer;\n    res.eta = p.eta;\n    res.startBlock = p.startBlock;\n    res.endBlock = p.endBlock;\n    res.forVotes = p.forVotes;\n    res.againstVotes = p.againstVotes;\n    res.abstainVotes = p.abstainVotes;\n    res.canceled = p.canceled;\n    res.executed = p.executed;\n  }\n\n  function getGovBravoProposals(GovernorBravoInterface governor, uint256[] calldata proposalIds) external view returns (GovBravoProposal[] memory) {\n    GovBravoProposal[] memory res = new GovBravoProposal[](proposalIds.length);\n    for (uint256 i = 0; i < proposalIds.length; i++) {\n      (address[] memory targets, uint256[] memory values, string[] memory signatures, bytes[] memory calldatas) = governor.getActions(proposalIds[i]);\n      res[i] = GovBravoProposal({\n        proposalId: 0,\n        proposer: address(0),\n        eta: 0,\n        targets: targets,\n        values: values,\n        signatures: signatures,\n        calldatas: calldatas,\n        startBlock: 0,\n        endBlock: 0,\n        forVotes: 0,\n        againstVotes: 0,\n        abstainVotes: 0,\n        canceled: false,\n        executed: false\n      });\n      setBravoProposal(res[i], governor, proposalIds[i]);\n    }\n    return res;\n  }\n\n  struct CompBalanceMetadata {\n    uint256 balance;\n    uint256 votes;\n    address delegate;\n  }\n\n  function getCompBalanceMetadata(Comp comp, address account) external view returns (CompBalanceMetadata memory) {\n    return CompBalanceMetadata({ balance: comp.balanceOf(account), votes: uint256(comp.getCurrentVotes(account)), delegate: comp.delegates(account) });\n  }\n\n  struct CompBalanceMetadataExt {\n    uint256 balance;\n    uint256 votes;\n    address delegate;\n    uint256 allocated;\n  }\n\n  function getCompBalanceMetadataExt(\n    Comp comp,\n    ComptrollerLensInterface comptroller,\n    address account\n  ) external returns (CompBalanceMetadataExt memory) {\n    uint256 balance = comp.balanceOf(account);\n    comptroller.claimComp(account);\n    uint256 newBalance = comp.balanceOf(account);\n    uint256 accrued = comptroller.compAccrued(account);\n    uint256 total = add(accrued, newBalance, \"sum comp total\");\n    uint256 allocated = sub(total, balance, \"sub allocated\");\n\n    return CompBalanceMetadataExt({ balance: balance, votes: uint256(comp.getCurrentVotes(account)), delegate: comp.delegates(account), allocated: allocated });\n  }\n\n  function getClaimMarketData(\n    Comp comp,\n    ComptrollerLens2Interface comptroller,\n    address account,\n    CToken[] calldata markets\n  ) external returns (uint256[] memory) {\n    uint256[] memory claimableAmounts = new uint256[](markets.length);\n    uint256 baseAccrual = comptroller.compAccrued(account);\n    uint256 balance = add(comp.balanceOf(account), baseAccrual, \"initial balance with base accrual\");\n    address[] memory accounts = new address[](1);\n    accounts[0] = account;\n    for (uint256 i = 0; i < markets.length; i++) {\n      CToken[] memory marketSlice = new CToken[](1);\n      marketSlice[0] = markets[i];\n      comptroller.claimComp(accounts, marketSlice, false, true);\n      uint256 newBalance = add(comp.balanceOf(account), comptroller.compAccrued(account), \"error getting new balance\");\n      claimableAmounts[i] = sub(newBalance, balance, \"get the difference of comp balance\");\n      balance = newBalance;\n    }\n    return claimableAmounts;\n  }\n\n  struct CompVotes {\n    uint256 blockNumber;\n    uint256 votes;\n  }\n\n  function getCompVotes(\n    Comp comp,\n    address account,\n    uint32[] calldata blockNumbers\n  ) external view returns (CompVotes[] memory) {\n    CompVotes[] memory res = new CompVotes[](blockNumbers.length);\n    for (uint256 i = 0; i < blockNumbers.length; i++) {\n      res[i] = CompVotes({ blockNumber: uint256(blockNumbers[i]), votes: uint256(comp.getPriorVotes(account, blockNumbers[i])) });\n    }\n    return res;\n  }\n\n  function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n\n  function add(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n    return c;\n  }\n}\n"
    },
    "contracts/Governance/GovernorAlpha.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ncontract GovernorAlpha {\n  /// @notice The name of this contract\n  string public constant name = \"Compound Governor Alpha\";\n\n  /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n  function quorumVotes() public pure returns (uint256) {\n    return 400000e18;\n  } // 400,000 = 4% of Comp\n\n  /// @notice The number of votes required in order for a voter to become a proposer\n  function proposalThreshold() public pure returns (uint256) {\n    return 100000e18;\n  } // 100,000 = 1% of Comp\n\n  /// @notice The maximum number of actions that can be included in a proposal\n  function proposalMaxOperations() public pure returns (uint256) {\n    return 10;\n  } // 10 actions\n\n  /// @notice The delay before voting on a proposal may take place, once proposed\n  function votingDelay() public pure returns (uint256) {\n    return 1;\n  } // 1 block\n\n  /// @notice The duration of voting on a proposal, in blocks\n  function votingPeriod() public pure virtual returns (uint256) {\n    return 17280;\n  } // ~3 days in blocks (assuming 15s blocks)\n\n  /// @notice The address of the Compound Protocol Timelock\n  TimelockInterface public timelock;\n\n  /// @notice The address of the Compound governance token\n  CompInterface public comp;\n\n  /// @notice The address of the Governor Guardian\n  address public guardian;\n\n  /// @notice The total number of proposals\n  uint256 public proposalCount;\n\n  struct Proposal {\n    /// @notice Unique id for looking up a proposal\n    uint256 id;\n    /// @notice Creator of the proposal\n    address proposer;\n    /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n    uint256 eta;\n    /// @notice the ordered list of target addresses for calls to be made\n    address[] targets;\n    /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n    uint256[] values;\n    /// @notice The ordered list of function signatures to be called\n    string[] signatures;\n    /// @notice The ordered list of calldata to be passed to each call\n    bytes[] calldatas;\n    /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n    uint256 startBlock;\n    /// @notice The block at which voting ends: votes must be cast prior to this block\n    uint256 endBlock;\n    /// @notice Current number of votes in favor of this proposal\n    uint256 forVotes;\n    /// @notice Current number of votes in opposition to this proposal\n    uint256 againstVotes;\n    /// @notice Flag marking whether the proposal has been canceled\n    bool canceled;\n    /// @notice Flag marking whether the proposal has been executed\n    bool executed;\n    /// @notice Receipts of ballots for the entire set of voters\n    mapping(address => Receipt) receipts;\n  }\n\n  /// @notice Ballot receipt record for a voter\n  struct Receipt {\n    /// @notice Whether or not a vote has been cast\n    bool hasVoted;\n    /// @notice Whether or not the voter supports the proposal\n    bool support;\n    /// @notice The number of votes the voter had, which were cast\n    uint96 votes;\n  }\n\n  /// @notice Possible states that a proposal may be in\n  enum ProposalState {\n    Pending,\n    Active,\n    Canceled,\n    Defeated,\n    Succeeded,\n    Queued,\n    Expired,\n    Executed\n  }\n\n  /// @notice The official record of all proposals ever proposed\n  mapping(uint256 => Proposal) public proposals;\n\n  /// @notice The latest proposal for each proposer\n  mapping(address => uint256) public latestProposalIds;\n\n  /// @notice The EIP-712 typehash for the contract's domain\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n  /// @notice The EIP-712 typehash for the ballot struct used by the contract\n  bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n  /// @notice An event emitted when a new proposal is created\n  event ProposalCreated(\n    uint256 id,\n    address proposer,\n    address[] targets,\n    uint256[] values,\n    string[] signatures,\n    bytes[] calldatas,\n    uint256 startBlock,\n    uint256 endBlock,\n    string description\n  );\n\n  /// @notice An event emitted when a vote has been cast on a proposal\n  event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n  /// @notice An event emitted when a proposal has been canceled\n  event ProposalCanceled(uint256 id);\n\n  /// @notice An event emitted when a proposal has been queued in the Timelock\n  event ProposalQueued(uint256 id, uint256 eta);\n\n  /// @notice An event emitted when a proposal has been executed in the Timelock\n  event ProposalExecuted(uint256 id);\n\n  constructor(\n    address timelock_,\n    address comp_,\n    address guardian_\n  ) public {\n    timelock = TimelockInterface(timelock_);\n    comp = CompInterface(comp_);\n    guardian = guardian_;\n  }\n\n  function propose(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    string memory description\n  ) public returns (uint256) {\n    require(comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n    require(\n      targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\n      \"GovernorAlpha::propose: proposal function information arity mismatch\"\n    );\n    require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n    require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n    uint256 latestProposalId = latestProposalIds[msg.sender];\n    if (latestProposalId != 0) {\n      ProposalState proposersLatestProposalState = state(latestProposalId);\n      require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n      require(\n        proposersLatestProposalState != ProposalState.Pending,\n        \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n      );\n    }\n\n    uint256 startBlock = add256(block.number, votingDelay());\n    uint256 endBlock = add256(startBlock, votingPeriod());\n\n    proposalCount++;\n    uint256 proposalId = proposalCount;\n    Proposal storage newProposal = proposals[proposalId];\n    // This should never happen but add a check in case.\n    require(newProposal.id == 0, \"GovernorAlpha::propose: ProposalID collsion\");\n    newProposal.id = proposalId;\n    newProposal.proposer = msg.sender;\n    newProposal.eta = 0;\n    newProposal.targets = targets;\n    newProposal.values = values;\n    newProposal.signatures = signatures;\n    newProposal.calldatas = calldatas;\n    newProposal.startBlock = startBlock;\n    newProposal.endBlock = endBlock;\n    newProposal.forVotes = 0;\n    newProposal.againstVotes = 0;\n    newProposal.canceled = false;\n    newProposal.executed = false;\n\n    latestProposalIds[newProposal.proposer] = newProposal.id;\n\n    emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n    return newProposal.id;\n  }\n\n  function queue(uint256 proposalId) public {\n    require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n    Proposal storage proposal = proposals[proposalId];\n    uint256 eta = add256(block.timestamp, timelock.delay());\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n    }\n    proposal.eta = eta;\n    emit ProposalQueued(proposalId, eta);\n  }\n\n  function _queueOrRevert(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) internal {\n    require(\n      !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n      \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\"\n    );\n    timelock.queueTransaction(target, value, signature, data, eta);\n  }\n\n  function execute(uint256 proposalId) public payable {\n    require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n    Proposal storage proposal = proposals[proposalId];\n    proposal.executed = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      timelock.executeTransaction{ value: proposal.values[i] }(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n    emit ProposalExecuted(proposalId);\n  }\n\n  function cancel(uint256 proposalId) public {\n    ProposalState state = state(proposalId);\n    require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n    Proposal storage proposal = proposals[proposalId];\n    require(\n      msg.sender == guardian || comp.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(),\n      \"GovernorAlpha::cancel: proposer above threshold\"\n    );\n\n    proposal.canceled = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n    }\n\n    emit ProposalCanceled(proposalId);\n  }\n\n  function getActions(uint256 proposalId)\n    public\n    view\n    returns (\n      address[] memory targets,\n      uint256[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    )\n  {\n    Proposal storage p = proposals[proposalId];\n    return (p.targets, p.values, p.signatures, p.calldatas);\n  }\n\n  function getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n    return proposals[proposalId].receipts[voter];\n  }\n\n  function state(uint256 proposalId) public view returns (ProposalState) {\n    require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n    Proposal storage proposal = proposals[proposalId];\n    if (proposal.canceled) {\n      return ProposalState.Canceled;\n    } else if (block.number <= proposal.startBlock) {\n      return ProposalState.Pending;\n    } else if (block.number <= proposal.endBlock) {\n      return ProposalState.Active;\n    } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n      return ProposalState.Defeated;\n    } else if (proposal.eta == 0) {\n      return ProposalState.Succeeded;\n    } else if (proposal.executed) {\n      return ProposalState.Executed;\n    } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n      return ProposalState.Expired;\n    } else {\n      return ProposalState.Queued;\n    }\n  }\n\n  function castVote(uint256 proposalId, bool support) public {\n    return _castVote(msg.sender, proposalId, support);\n  }\n\n  function castVoteBySig(\n    uint256 proposalId,\n    bool support,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n    bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n    return _castVote(signatory, proposalId, support);\n  }\n\n  function _castVote(\n    address voter,\n    uint256 proposalId,\n    bool support\n  ) internal {\n    require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n    Proposal storage proposal = proposals[proposalId];\n    Receipt storage receipt = proposal.receipts[voter];\n    require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n    uint96 votes = comp.getPriorVotes(voter, proposal.startBlock);\n\n    if (support) {\n      proposal.forVotes = add256(proposal.forVotes, votes);\n    } else {\n      proposal.againstVotes = add256(proposal.againstVotes, votes);\n    }\n\n    receipt.hasVoted = true;\n    receipt.support = support;\n    receipt.votes = votes;\n\n    emit VoteCast(voter, proposalId, support, votes);\n  }\n\n  function __acceptAdmin() public {\n    require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n    timelock.acceptAdmin();\n  }\n\n  function __abdicate() public {\n    require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n    guardian = address(0);\n  }\n\n  function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n    require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n    timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n  }\n\n  function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n    require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n    timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n  }\n\n  function add256(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"addition overflow\");\n    return c;\n  }\n\n  function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"subtraction underflow\");\n    return a - b;\n  }\n\n  function getChainId() internal view returns (uint256) {\n    uint256 chainId;\n    assembly {\n      chainId := chainid()\n    }\n    return chainId;\n  }\n}\n\ninterface TimelockInterface {\n  function delay() external view returns (uint256);\n\n  function GRACE_PERIOD() external view returns (uint256);\n\n  function acceptAdmin() external;\n\n  function queuedTransactions(bytes32 hash) external view returns (bool);\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external returns (bytes32);\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external;\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external payable returns (bytes memory);\n}\n\ninterface CompInterface {\n  function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n}\n"
    },
    "contracts/Governance/Comp.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ncontract Comp {\n  /// @notice EIP-20 token name for this token\n  string public constant name = \"Bonded dAMM\";\n\n  /// @notice EIP-20 token symbol for this token\n  string public constant symbol = \"BDAMM\";\n\n  /// @notice EIP-20 token decimals for this token\n  uint8 public constant decimals = 18;\n\n  /// @notice Total number of tokens in circulation\n  uint256 public constant totalSupply = 250000000e18; // 250 million bdAMM\n\n  /// @notice Allowance amounts on behalf of others\n  mapping(address => mapping(address => uint96)) internal allowances;\n\n  /// @notice Official record of token balances for each account\n  mapping(address => uint96) internal balances;\n\n  /// @notice A record of each accounts delegate\n  mapping(address => address) public delegates;\n\n  /// @notice A checkpoint for marking number of votes from a given block\n  struct Checkpoint {\n    uint32 fromBlock;\n    uint96 votes;\n  }\n\n  /// @notice A record of votes checkpoints for each account, by index\n  mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n  /// @notice The number of checkpoints for each account\n  mapping(address => uint32) public numCheckpoints;\n\n  /// @notice The EIP-712 typehash for the contract's domain\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n  /// @notice The EIP-712 typehash for the delegation struct used by the contract\n  bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n  /// @notice A record of states for signing / validating signatures\n  mapping(address => uint256) public nonces;\n\n  /// @notice An event thats emitted when an account changes its delegate\n  event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n  /// @notice An event thats emitted when a delegate account's vote balance changes\n  event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n  /// @notice The standard EIP-20 transfer event\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  /// @notice The standard EIP-20 approval event\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n  /**\n   * @notice Construct a new Comp token\n   * @param account The initial account to grant all the tokens\n   */\n  constructor(address account) public {\n    balances[account] = uint96(totalSupply);\n    emit Transfer(address(0), account, totalSupply);\n  }\n\n  /**\n   * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n   * @param account The address of the account holding the funds\n   * @param spender The address of the account spending the funds\n   * @return The number of tokens approved\n   */\n  function allowance(address account, address spender) external view returns (uint256) {\n    return allowances[account][spender];\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 rawAmount) external returns (bool) {\n    uint96 amount;\n    if (rawAmount == type(uint256).max) {\n      amount = type(uint96).max;\n    } else {\n      amount = safe96(rawAmount, \"BDAMM::approve: amount exceeds 96 bits\");\n    }\n\n    allowances[msg.sender][spender] = amount;\n\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Get the number of tokens held by the `account`\n   * @param account The address of the account to get the balance of\n   * @return The number of tokens held\n   */\n  function balanceOf(address account) external view returns (uint256) {\n    return balances[account];\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param rawAmount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 rawAmount) external returns (bool) {\n    uint96 amount = safe96(rawAmount, \"BDAMM::transfer: amount exceeds 96 bits\");\n    _transferTokens(msg.sender, dst, amount);\n    return true;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param rawAmount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 rawAmount\n  ) external returns (bool) {\n    address spender = msg.sender;\n    uint96 spenderAllowance = allowances[src][spender];\n    uint96 amount = safe96(rawAmount, \"BDAMM::approve: amount exceeds 96 bits\");\n\n    if (spender != src && spenderAllowance != type(uint96).max) {\n      uint96 newAllowance = sub96(spenderAllowance, amount, \"BDAMM::transferFrom: transfer amount exceeds spender allowance\");\n      allowances[src][spender] = newAllowance;\n\n      emit Approval(src, spender, newAllowance);\n    }\n\n    _transferTokens(src, dst, amount);\n    return true;\n  }\n\n  /**\n   * @notice Delegate votes from `msg.sender` to `delegatee`\n   * @param delegatee The address to delegate votes to\n   */\n  function delegate(address delegatee) public {\n    return _delegate(msg.sender, delegatee);\n  }\n\n  /**\n   * @notice Delegates votes from signatory to `delegatee`\n   * @param delegatee The address to delegate votes to\n   * @param nonce The contract state required to match the signature\n   * @param expiry The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function delegateBySig(\n    address delegatee,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n    bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"BDAMM::delegateBySig: invalid signature\");\n    require(nonce == nonces[signatory]++, \"BDAMM::delegateBySig: invalid nonce\");\n    require(block.timestamp <= expiry, \"BDAMM::delegateBySig: signature expired\");\n    return _delegate(signatory, delegatee);\n  }\n\n  /**\n   * @notice Gets the current votes balance for `account`\n   * @param account The address to get votes balance\n   * @return The number of current votes for `account`\n   */\n  function getCurrentVotes(address account) external view returns (uint96) {\n    uint32 nCheckpoints = numCheckpoints[account];\n    return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n  }\n\n  /**\n   * @notice Determine the prior number of votes for an account as of a block number\n   * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n   * @param account The address of the account to check\n   * @param blockNumber The block number to get the vote balance at\n   * @return The number of votes the account had as of the given block\n   */\n  function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {\n    require(blockNumber < block.number, \"BDAMM::getPriorVotes: not yet determined\");\n\n    uint32 nCheckpoints = numCheckpoints[account];\n    if (nCheckpoints == 0) {\n      return 0;\n    }\n\n    // First check most recent balance\n    if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n      return checkpoints[account][nCheckpoints - 1].votes;\n    }\n\n    // Next check implicit zero balance\n    if (checkpoints[account][0].fromBlock > blockNumber) {\n      return 0;\n    }\n\n    uint32 lower = 0;\n    uint32 upper = nCheckpoints - 1;\n    while (upper > lower) {\n      uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n      Checkpoint memory cp = checkpoints[account][center];\n      if (cp.fromBlock == blockNumber) {\n        return cp.votes;\n      } else if (cp.fromBlock < blockNumber) {\n        lower = center;\n      } else {\n        upper = center - 1;\n      }\n    }\n    return checkpoints[account][lower].votes;\n  }\n\n  function _delegate(address delegator, address delegatee) internal {\n    address currentDelegate = delegates[delegator];\n    uint96 delegatorBalance = balances[delegator];\n    delegates[delegator] = delegatee;\n\n    emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n    _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n  }\n\n  function _transferTokens(\n    address src,\n    address dst,\n    uint96 amount\n  ) internal {\n    require(src != address(0), \"BDAMM::_transferTokens: cannot transfer from the zero address\");\n    require(dst != address(0), \"BDAMM::_transferTokens: cannot transfer to the zero address\");\n\n    balances[src] = sub96(balances[src], amount, \"BDAMM::_transferTokens: transfer amount exceeds balance\");\n    balances[dst] = add96(balances[dst], amount, \"BDAMM::_transferTokens: transfer amount overflows\");\n    emit Transfer(src, dst, amount);\n\n    _moveDelegates(delegates[src], delegates[dst], amount);\n  }\n\n  function _moveDelegates(\n    address srcRep,\n    address dstRep,\n    uint96 amount\n  ) internal {\n    if (srcRep != dstRep && amount > 0) {\n      if (srcRep != address(0)) {\n        uint32 srcRepNum = numCheckpoints[srcRep];\n        uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n        uint96 srcRepNew = sub96(srcRepOld, amount, \"BDAMM::_moveVotes: vote amount underflows\");\n        _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n      }\n\n      if (dstRep != address(0)) {\n        uint32 dstRepNum = numCheckpoints[dstRep];\n        uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n        uint96 dstRepNew = add96(dstRepOld, amount, \"BDAMM::_moveVotes: vote amount overflows\");\n        _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n      }\n    }\n  }\n\n  function _writeCheckpoint(\n    address delegatee,\n    uint32 nCheckpoints,\n    uint96 oldVotes,\n    uint96 newVotes\n  ) internal {\n    uint32 blockNumber = safe32(block.number, \"BDAMM::_writeCheckpoint: block number exceeds 32 bits\");\n\n    if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n      checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n    } else {\n      checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n      numCheckpoints[delegatee] = nCheckpoints + 1;\n    }\n\n    emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n  }\n\n  function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n    require(n < 2**96, errorMessage);\n    return uint96(n);\n  }\n\n  function add96(\n    uint96 a,\n    uint96 b,\n    string memory errorMessage\n  ) internal pure returns (uint96) {\n    uint96 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub96(\n    uint96 a,\n    uint96 b,\n    string memory errorMessage\n  ) internal pure returns (uint96) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function getChainId() internal view returns (uint256) {\n    uint256 chainId;\n    assembly {\n      chainId := chainid()\n    }\n    return chainId;\n  }\n}\n"
    },
    "contracts/Dammtroller/Dammtroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"../CToken.sol\";\nimport \"../ErrorReporter.sol\";\nimport \"../PriceOracle.sol\";\nimport \"../ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./DammtrollerProxy.sol\";\nimport \"../Governance/Comp.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n */\ncontract Dammtroller is ComptrollerV5Storage, ComptrollerInterface, ComptrollerErrorReporter, ExponentialNoError {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(CToken cToken);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(CToken cToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(CToken cToken, address account);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(string action, bool pauseState);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPaused(CToken cToken, string action, bool pauseState);\n\n    /// @notice Emitted when a new COMP speed is calculated for a market\n    event CompSpeedUpdated(CToken indexed cToken, uint newSpeed);\n\n    /// @notice Emitted when a new COMP speed is set for a contributor\n    event ContributorCompSpeedUpdated(address indexed contributor, uint newSpeed);\n\n    /// @notice Emitted when COMP is distributed to a supplier\n    event DistributedSupplierComp(CToken indexed cToken, address indexed supplier, uint compDelta, uint compSupplyIndex);\n\n    /// @notice Emitted when COMP is distributed to a borrower\n    event DistributedBorrowerComp(CToken indexed cToken, address indexed borrower, uint compDelta, uint compBorrowIndex);\n\n    /// @notice Emitted when borrow cap for a cToken is changed\n    event NewBorrowCap(CToken indexed cToken, uint newBorrowCap);\n\n    /// @notice Emitted when borrow cap guardian is changed\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n\n    /// @notice Emitted when new borrower is whitelisted\n    event BorrowerWhitelisted(address borrower);\n\n    /// @notice Emitted when borrower's limits are changed\n    event BorrowerLimitChanged(address borrower, uint256 borrowLimit);\n\n    /// @notice Emitted when COMP is granted by admin\n    event CompGranted(address recipient, uint amount);\n\n    /// @notice The initial COMP index for a market\n    uint224 public constant compInitialIndex = 1e36;\n\n    // closeFactorMantissa must be strictly greater than this value\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    // No collateralFactorMantissa may exceed this value\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n    constructor(address compAddress) public {\n        _compAddress = compAddress;\n        admin = msg.sender;\n    }\n\n    /*** Assets You Are In ***/\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (CToken[] memory) {\n        CToken[] memory assetsIn = accountAssets[account];\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, CToken cToken) external view returns (bool) {\n        return markets[address(cToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] memory cTokens) override public returns (uint[] memory) {\n        uint len = cTokens.length;\n\n        uint[] memory results = new uint[](len);\n        for (uint i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n\n            results[i] = uint(addToMarketInternal(cToken, msg.sender));\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param cToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n    function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\n        Market storage marketToJoin = markets[address(cToken)];\n\n        if (!marketToJoin.isListed) {\n            // market is not listed, cannot join\n            return Error.MARKET_NOT_LISTED;\n        }\n\n        if (marketToJoin.accountMembership[borrower] == true) {\n            // already joined\n            return Error.NO_ERROR;\n        }\n\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(cToken);\n\n        emit MarketEntered(cToken, borrower);\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address cTokenAddress) override external returns (uint) {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = markets[address(cToken)];\n\n        /* Return true if the sender is not already in the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the accounts list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint len = userAssetList.length;\n        uint assetIndex = len;\n        for (uint i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.pop();\n\n        emit MarketExited(cToken, msg.sender);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(address cToken, address minter, uint mintAmount) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n        // Shh - currently unused\n        minter;\n        mintAmount;\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cToken);\n        distributeSupplierComp(cToken, minter);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates mint and reverts on rejection. May emit logs.\n     * @param cToken Asset being minted\n     * @param minter The address minting the tokens\n     * @param actualMintAmount The amount of the underlying asset being minted\n     * @param mintTokens The number of tokens being minted\n     */\n    function mintVerify(address cToken, address minter, uint actualMintAmount, uint mintTokens) override external {\n        // Shh - currently unused\n        cToken;\n        minter;\n        actualMintAmount;\n        mintTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) override external returns (uint) {\n        uint allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n        if (allowed != uint(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cToken);\n        distributeSupplierComp(cToken, redeemer);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal view returns (uint) {\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!markets[cToken].accountMembership[redeemer]) {\n            return uint(Error.NO_ERROR);\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) override external {\n        // Shh - currently unused\n        cToken;\n        redeemer;\n\n        // Require tokens is zero or amount is also zero\n        if (redeemTokens == 0 && redeemAmount > 0) {\n            revert(\"redeemTokens zero\");\n        }\n    }\n\n    function whitelistBorrowerAdd(address borrower) public override returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_BORROWER_LIMIT_CHECK);\n        }\n\n        borrowerArray[borrower] = true;\n        borrowLimit[borrower] = 0;\n\n        emit BorrowerWhitelisted(borrower);\n\n\n        return 0;\n    }\n\n    //Sets the notional limit of borrows for an address\n    function setBorrowerLimits(address borrower, uint256 _borrowLimit) public override returns (uint) {\n        if (msg.sender != admin || borrowerArray[borrower] != true) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_BORROWER_LIMIT_CHECK);\n        }\n        borrowLimit[borrower] = _borrowLimit;\n\n        emit BorrowerLimitChanged(borrower, _borrowLimit);\n\n        return (_borrowLimit);\n    }\n\n    //Returns the notional value of borrows allowed for a borrower\n    function getBorrowerLimits(address borrower) public override view returns (uint256) {\n        require(borrowerArray[borrower] == true, \"Address not permitted to borrow\");\n        return borrowLimit[borrower];\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        if (!markets[cToken].accountMembership[borrower]) {\n            // only cTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == cToken, \"sender must be cToken\");\n\n            // attempt to add borrower to the market\n            Error err = addToMarketInternal(CToken(msg.sender), borrower);\n            if (err != Error.NO_ERROR) {\n                return uint(err);\n            }\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[borrower]);\n        }\n\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n            return uint(Error.PRICE_ERROR);\n        }\n\n        uint borrowCap = borrowCaps[cToken];\n        // Borrow cap of 0 corresponds to unlimited borrowing\n        if (borrowCap != 0) {\n            uint totalBorrows = CToken(cToken).totalBorrows();\n            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n        }\n\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);\n        if (err != Error.NO_ERROR) {\n            return uint(err);\n        }\n\n        if (shortfall > 0) {\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});\n        updateCompBorrowIndex(cToken, borrowIndex);\n        distributeBorrowerComp(cToken, borrower, borrowIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates borrow and reverts on rejection. May emit logs.\n     * @param cToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) override external {\n        // Shh - currently unused\n        cToken;\n        borrower;\n        borrowAmount;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount) override external returns (uint) {\n        // Shh - currently unused\n        payer;\n        borrower;\n        repayAmount;\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});\n        updateCompBorrowIndex(cToken, borrowIndex);\n        distributeBorrowerComp(cToken, borrower, borrowIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\n     * @param cToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint actualRepayAmount,\n        uint borrowerIndex) override external {\n        // Shh - currently unused\n        cToken;\n        payer;\n        borrower;\n        actualRepayAmount;\n        borrowerIndex;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount) override external returns (uint) {\n        // Shh - currently unused\n        liquidator;\n\n        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\n        uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n        uint maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\n        if (repayAmount > maxClose) {\n            return uint(Error.TOO_MUCH_REPAY);\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint actualRepayAmount,\n        uint seizeTokens) override external {\n        // Shh - currently unused\n        cTokenBorrowed;\n        cTokenCollateral;\n        liquidator;\n        borrower;\n        actualRepayAmount;\n        seizeTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n        // Shh - currently unused\n        seizeTokens;\n\n        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n            return uint(Error.COMPTROLLER_MISMATCH);\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cTokenCollateral);\n        distributeSupplierComp(cTokenCollateral, borrower);\n        distributeSupplierComp(cTokenCollateral, liquidator);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates seize and reverts on rejection. May emit logs.\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) override external {\n        // Shh - currently unused\n        cTokenCollateral;\n        cTokenBorrowed;\n        liquidator;\n        borrower;\n        seizeTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!transferGuardianPaused, \"transfer is paused\");\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint allowed = redeemAllowedInternal(cToken, src, transferTokens);\n        if (allowed != uint(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cToken);\n        distributeSupplierComp(cToken, src);\n        distributeSupplierComp(cToken, dst);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates transfer and reverts on rejection. May emit logs.\n     * @param cToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     */\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) override external {\n        // Shh - currently unused\n        cToken;\n        src;\n        dst;\n        transferTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint sumCollateral;\n        uint sumBorrowPlusEffects;\n        uint cTokenBalance;\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n        uint oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(address(0)), 0, 0);\n\n        return (uint(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n        return getHypotheticalAccountLiquidityInternal(account, CToken(address(0)), 0, 0);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address cTokenModify,\n        uint redeemTokens,\n        uint borrowAmount) public view returns (uint, uint, uint) {\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(cTokenModify), redeemTokens, borrowAmount);\n        return (uint(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        CToken cTokenModify,\n        uint redeemTokens,\n        uint borrowAmount) internal view returns (Error, uint, uint) {\n\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint oErr;\n\n        // For each asset the account is in\n        CToken[] memory assets = accountAssets[account];\n\n        /*\n          Start with an assumed collateral value equal to the borrower limit. This sets a baseline for determining\n          whether borrows and redemptions should be allowed\n        */\n        vars.sumCollateral = borrowLimit[account];\n\n        for (uint i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n                return (Error.SNAPSHOT_ERROR, 0, 0);\n            }\n            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n            if (vars.oraclePriceMantissa == 0) {\n                return (Error.PRICE_ERROR, 0, 0);\n            }\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n            // sumCollateral += tokensToDenom * cTokenBalance\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\n\n            // Calculate effects of interacting with cTokenModify\n            if (asset == cTokenModify) {\n                // redeem effect\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\n\n                // borrow effect\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\n            }\n        }\n\n        // These are safe, as the underflow condition is checked first\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n        } else {\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n        }\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param cTokenCollateral The address of the collateral cToken\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint actualRepayAmount) override external view returns (uint, uint) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n            return (uint(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\n        uint seizeTokens;\n        Exp memory numerator;\n        Exp memory denominator;\n        Exp memory ratio;\n\n        numerator = mul_(Exp({mantissa: liquidationIncentiveMantissa}), Exp({mantissa: priceBorrowedMantissa}));\n        denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\n        ratio = div_(numerator, denominator);\n\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n\n        return (uint(Error.NO_ERROR), seizeTokens);\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n      * @notice Sets a new price oracle for the comptroller\n      * @dev Admin function to set a new price oracle\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n        }\n\n        // Track the old oracle for the comptroller\n        PriceOracle oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets the closeFactor used when liquidating borrows\n      * @dev Admin function to set closeFactor\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\n      * @return uint 0=success, otherwise a failure\n      */\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n        // Check caller is admin\n        require(msg.sender == admin, \"only admin can set close factor\");\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets the collateralFactor for a market\n      * @dev Admin function to set per-market collateralFactor\n      * @param cToken The market to set the factor on\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n        }\n\n        // Verify market is listed\n        Market storage market = markets[address(cToken)];\n        if (!market.isListed) {\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n        }\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n        // Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets liquidationIncentive\n      * @dev Admin function to set liquidationIncentive\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n        }\n\n        // Save current value for use in log\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Add the market to the markets mapping and set it as listed\n      * @dev Admin function to set isListed and add support for the market\n      * @param cToken The address of the market (token) to list\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n      */\n    function _supportMarket(CToken cToken) external returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        if (markets[address(cToken)].isListed) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n        // Note that isComped is not in active use anymore\n        Market storage market = markets[address(cToken)];\n        market.isListed = true;\n        market.isComped = false;\n        market.collateralFactorMantissa = 0;\n\n        _addMarketInternal(address(cToken));\n\n        emit MarketListed(cToken);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function _addMarketInternal(address cToken) internal {\n        for (uint i = 0; i < allMarkets.length; i ++) {\n            require(allMarkets[i] != CToken(cToken), \"market already added\");\n        }\n        allMarkets.push(CToken(cToken));\n    }\n\n\n    /**\n      * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\n      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\n      * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n      */\n    function _setMarketBorrowCaps(CToken[] calldata cTokens, uint[] calldata newBorrowCaps) external {\n        require(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\n\n        uint numMarkets = cTokens.length;\n        uint numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for(uint i = 0; i < numMarkets; i++) {\n            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Admin function to change the Borrow Cap Guardian\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\n     */\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n\n        // Save current value for inclusion in log\n        address oldBorrowCapGuardian = borrowCapGuardian;\n\n        // Store borrowCapGuardian with value newBorrowCapGuardian\n        borrowCapGuardian = newBorrowCapGuardian;\n\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n        }\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        mintGuardianPaused[address(cToken)] = state;\n        emit ActionPaused(cToken, \"Mint\", state);\n        return state;\n    }\n\n    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        borrowGuardianPaused[address(cToken)] = state;\n        emit ActionPaused(cToken, \"Borrow\", state);\n        return state;\n    }\n\n    function _setTransferPaused(bool state) public returns (bool) {\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        transferGuardianPaused = state;\n        emit ActionPaused(\"Transfer\", state);\n        return state;\n    }\n\n    function _setSeizePaused(bool state) public returns (bool) {\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        seizeGuardianPaused = state;\n        emit ActionPaused(\"Seize\", state);\n        return state;\n    }\n\n    function _become(DammtrollerProxy unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n    }\n\n    /**\n     * @notice Checks caller is admin, or this contract is becoming the new implementation\n     */\n    function adminOrInitializing() internal view returns (bool) {\n        return msg.sender == admin || msg.sender == comptrollerImplementation;\n    }\n\n    /*** Comp Distribution ***/\n\n    /**\n     * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param compSpeed New COMP speed for market\n     */\n    function setCompSpeedInternal(CToken cToken, uint compSpeed) internal {\n        uint currentCompSpeed = compSpeeds[address(cToken)];\n        if (currentCompSpeed != 0) {\n            // note that COMP speed could be set to 0 to halt liquidity rewards for a market\n            Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});\n            updateCompSupplyIndex(address(cToken));\n            updateCompBorrowIndex(address(cToken), borrowIndex);\n        } else if (compSpeed != 0) {\n            // Add the COMP market\n            Market storage market = markets[address(cToken)];\n            require(market.isListed == true, \"comp market is not listed\");\n\n            if (compSupplyState[address(cToken)].index == 0 && compSupplyState[address(cToken)].block == 0) {\n                compSupplyState[address(cToken)] = CompMarketState({\n                    index: compInitialIndex,\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n                });\n            }\n\n            if (compBorrowState[address(cToken)].index == 0 && compBorrowState[address(cToken)].block == 0) {\n                compBorrowState[address(cToken)] = CompMarketState({\n                    index: compInitialIndex,\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n                });\n            }\n        }\n\n        if (currentCompSpeed != compSpeed) {\n            compSpeeds[address(cToken)] = compSpeed;\n            emit CompSpeedUpdated(cToken, compSpeed);\n        }\n    }\n\n    /**\n     * @notice Accrue COMP to the market by updating the supply index\n     * @param cToken The market whose supply index to update\n     */\n    function updateCompSupplyIndex(address cToken) internal {\n        CompMarketState storage supplyState = compSupplyState[cToken];\n        uint supplySpeed = compSpeeds[cToken];\n        uint blockNumber = getBlockNumber();\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\n        if (deltaBlocks > 0 && supplySpeed > 0) {\n            uint supplyTokens = CToken(cToken).totalSupply();\n            uint compAccrued = mul_(deltaBlocks, supplySpeed);\n            Double memory ratio = supplyTokens > 0 ? fraction(compAccrued, supplyTokens) : Double({mantissa: 0});\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n            compSupplyState[cToken] = CompMarketState({\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n            });\n        } else if (deltaBlocks > 0) {\n            supplyState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n        }\n    }\n\n    /**\n     * @notice Accrue COMP to the market by updating the borrow index\n     * @param cToken The market whose borrow index to update\n     */\n    function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex) internal {\n        CompMarketState storage borrowState = compBorrowState[cToken];\n        uint borrowSpeed = compSpeeds[cToken];\n        uint blockNumber = getBlockNumber();\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\n            uint borrowAmount = div_(CToken(cToken).totalBorrows(), marketBorrowIndex);\n            uint compAccrued = mul_(deltaBlocks, borrowSpeed);\n            Double memory ratio = borrowAmount > 0 ? fraction(compAccrued, borrowAmount) : Double({mantissa: 0});\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\n            compBorrowState[cToken] = CompMarketState({\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n            });\n        } else if (deltaBlocks > 0) {\n            borrowState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n        }\n    }\n\n    /**\n     * @notice Calculate COMP accrued by a supplier and possibly transfer it to them\n     * @param cToken The market in which the supplier is interacting\n     * @param supplier The address of the supplier to distribute COMP to\n     */\n    function distributeSupplierComp(address cToken, address supplier) internal {\n        CompMarketState storage supplyState = compSupplyState[cToken];\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\n        Double memory supplierIndex = Double({mantissa: compSupplierIndex[cToken][supplier]});\n        compSupplierIndex[cToken][supplier] = supplyIndex.mantissa;\n\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n            supplierIndex.mantissa = compInitialIndex;\n        }\n\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n        uint supplierTokens = CToken(cToken).balanceOf(supplier);\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\n        uint supplierAccrued = add_(compAccrued[supplier], supplierDelta);\n        compAccrued[supplier] = supplierAccrued;\n        emit DistributedSupplierComp(CToken(cToken), supplier, supplierDelta, supplyIndex.mantissa);\n    }\n\n    /**\n     * @notice Calculate COMP accrued by a borrower and possibly transfer it to them\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\n     * @param cToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute COMP to\n     */\n    function distributeBorrowerComp(address cToken, address borrower, Exp memory marketBorrowIndex) internal {\n        CompMarketState storage borrowState = compBorrowState[cToken];\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\n        Double memory borrowerIndex = Double({mantissa: compBorrowerIndex[cToken][borrower]});\n        compBorrowerIndex[cToken][borrower] = borrowIndex.mantissa;\n\n        if (borrowerIndex.mantissa > 0) {\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n            uint borrowerAmount = div_(CToken(cToken).borrowBalanceStored(borrower), marketBorrowIndex);\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\n            uint borrowerAccrued = add_(compAccrued[borrower], borrowerDelta);\n            compAccrued[borrower] = borrowerAccrued;\n            emit DistributedBorrowerComp(CToken(cToken), borrower, borrowerDelta, borrowIndex.mantissa);\n        }\n    }\n\n    /**\n     * @notice Calculate additional accrued COMP for a contributor since last accrual\n     * @param contributor The address to calculate contributor rewards for\n     */\n    function updateContributorRewards(address contributor) public {\n        uint compSpeed = compContributorSpeeds[contributor];\n        uint blockNumber = getBlockNumber();\n        uint deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\n        if (deltaBlocks > 0 && compSpeed > 0) {\n            uint newAccrued = mul_(deltaBlocks, compSpeed);\n            uint contributorAccrued = add_(compAccrued[contributor], newAccrued);\n\n            compAccrued[contributor] = contributorAccrued;\n            lastContributorBlock[contributor] = blockNumber;\n        }\n    }\n\n    /**\n     * @notice Claim all the comp accrued by holder in all markets\n     * @param holder The address to claim COMP for\n     */\n    function claimComp(address holder) public {\n        return claimComp(holder, allMarkets);\n    }\n\n    /**\n     * @notice Claim all the comp accrued by holder in the specified markets\n     * @param holder The address to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     */\n    function claimComp(address holder, CToken[] memory cTokens) public {\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        claimComp(holders, cTokens, true, true);\n    }\n\n    /**\n     * @notice Claim all comp accrued by the holders\n     * @param holders The addresses to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     * @param borrowers Whether or not to claim COMP earned by borrowing\n     * @param suppliers Whether or not to claim COMP earned by supplying\n     */\n    function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {\n        for (uint i = 0; i < cTokens.length; i++) {\n            CToken cToken = cTokens[i];\n            require(markets[address(cToken)].isListed, \"market must be listed\");\n            if (borrowers == true) {\n                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});\n                updateCompBorrowIndex(address(cToken), borrowIndex);\n                for (uint j = 0; j < holders.length; j++) {\n                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);\n                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);\n                }\n            }\n            if (suppliers == true) {\n                updateCompSupplyIndex(address(cToken));\n                for (uint j = 0; j < holders.length; j++) {\n                    distributeSupplierComp(address(cToken), holders[j]);\n                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Transfer COMP to the user\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n     * @param user The address of the user to transfer COMP to\n     * @param amount The amount of COMP to (possibly) transfer\n     * @return The amount of COMP which was NOT transferred to the user\n     */\n    function grantCompInternal(address user, uint amount) internal returns (uint) {\n        Comp comp = Comp(getCompAddress());\n        uint compRemaining = comp.balanceOf(address(this));\n        uint amountToTransfer = amount / 1e12;\n        if (amountToTransfer > 0 && amountToTransfer <= compRemaining) {\n            comp.transfer(user, amountToTransfer);\n            return 0;\n        }\n        return amount;\n    }\n\n    /*** Comp Distribution Admin ***/\n\n    /**\n     * @notice Transfer COMP to the recipient\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n     * @param recipient The address of the recipient to transfer COMP to\n     * @param amount The amount of COMP to (possibly) transfer\n     */\n    function _grantComp(address recipient, uint amount) public {\n        require(adminOrInitializing(), \"only admin can grant comp\");\n        uint amountLeft = grantCompInternal(recipient, amount);\n        require(amountLeft == 0, \"insufficient comp for grant\");\n        emit CompGranted(recipient, amount);\n    }\n\n    /**\n     * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param compSpeed New COMP speed for market\n     */\n    function _setCompSpeed(CToken cToken, uint compSpeed) public {\n        require(adminOrInitializing(), \"only admin can set comp speed\");\n        setCompSpeedInternal(cToken, compSpeed);\n    }\n\n    /**\n     * @notice Set COMP speed for a single contributor\n     * @param contributor The contributor whose COMP speed to update\n     * @param compSpeed New COMP speed for contributor\n     */\n    function _setContributorCompSpeed(address contributor, uint compSpeed) public {\n        require(adminOrInitializing(), \"only admin can set comp speed\");\n\n        // note that COMP speed could be set to 0 to halt liquidity rewards for a contributor\n        updateContributorRewards(contributor);\n        if (compSpeed == 0) {\n            // release storage\n            delete lastContributorBlock[contributor];\n        } else {\n            lastContributorBlock[contributor] = getBlockNumber();\n        }\n        compContributorSpeeds[contributor] = compSpeed;\n\n        emit ContributorCompSpeedUpdated(contributor, compSpeed);\n    }\n\n    /**\n     * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market.\n     * @return The list of market addresses\n     */\n    function getAllMarkets() public view returns (CToken[] memory) {\n        return allMarkets;\n    }\n\n    function getBlockNumber() public view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @notice Return the address of the COMP token\n     * @return The address of COMP\n     */\n    function getCompAddress() public view returns (address) {\n        return _compAddress;\n    }\n}\n"
    },
    "contracts/Dammtroller/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"../CToken.sol\";\nimport \"../PriceOracle.sol\";\n\ncontract UnitrollerAdminStorage {\n  /**\n   * @notice Administrator for this contract\n   */\n  address public admin;\n\n  /**\n   * @notice Pending administrator for this contract\n   */\n  address public pendingAdmin;\n\n  /**\n   * @notice Active brains of Unitroller\n   */\n  address public comptrollerImplementation;\n\n  /**\n   * @notice Pending brains of Unitroller\n   */\n  address public pendingComptrollerImplementation;\n\n  address internal _compAddress;\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n  /**\n   * @notice Oracle which gives the price of any given asset\n   */\n  PriceOracle public oracle;\n\n  /**\n   * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n   */\n  uint256 public closeFactorMantissa;\n\n  /**\n   * @notice Multiplier representing the discount on collateral that a liquidator receives\n   */\n  uint256 public liquidationIncentiveMantissa;\n\n  /**\n   * @notice Max number of assets a single account can participate in (borrow or use as collateral)\n   */\n  uint256 public maxAssets;\n\n  /**\n   * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n   */\n  mapping(address => CToken[]) public accountAssets;\n\n  mapping(address => bool) public borrowerArray;\n\n  mapping(address => uint256) public borrowLimit;\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n  struct Market {\n    // Whether or not this market is listed\n    bool isListed;\n    //  Multiplier representing the most one can borrow against their collateral in this market.\n    //  For instance, 0.9 to allow borrowing 90% of collateral value.\n    //  Must be between 0 and 1, and stored as a mantissa.\n    uint256 collateralFactorMantissa;\n    // Per-market mapping of \"accounts in this asset\"\n    mapping(address => bool) accountMembership;\n    // Whether or not this market receives COMP\n    bool isComped;\n  }\n\n  /**\n   * @notice Official mapping of cTokens -> Market metadata\n   * @dev Used e.g. to determine if a market is supported\n   */\n  mapping(address => Market) public markets;\n\n  /**\n   * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n   *  Actions which allow users to remove their own assets cannot be paused.\n   *  Liquidation / seizing / transfer can only be paused globally, not by market.\n   */\n  address public pauseGuardian;\n  bool public _mintGuardianPaused;\n  bool public _borrowGuardianPaused;\n  bool public transferGuardianPaused;\n  bool public seizeGuardianPaused;\n  mapping(address => bool) public mintGuardianPaused;\n  mapping(address => bool) public borrowGuardianPaused;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n  struct CompMarketState {\n    // The market's last updated compBorrowIndex or compSupplyIndex\n    uint224 index;\n    // The block number the index was last updated at\n    uint32 block;\n  }\n\n  /// @notice A list of all markets\n  CToken[] public allMarkets;\n\n  /// @notice The rate at which the flywheel distributes COMP, per block\n  uint256 public compRate;\n\n  /// @notice The portion of compRate that each market currently receives\n  mapping(address => uint256) public compSpeeds;\n\n  /// @notice The COMP market supply state for each market\n  mapping(address => CompMarketState) public compSupplyState;\n\n  /// @notice The COMP market borrow state for each market\n  mapping(address => CompMarketState) public compBorrowState;\n\n  /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP\n  mapping(address => mapping(address => uint256)) public compSupplierIndex;\n\n  /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP\n  mapping(address => mapping(address => uint256)) public compBorrowerIndex;\n\n  /// @notice The COMP accrued but not yet transferred to each user\n  mapping(address => uint256) public compAccrued;\n}\n\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\n  // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n  address public borrowCapGuardian;\n\n  // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n  mapping(address => uint256) public borrowCaps;\n}\n\ncontract ComptrollerV5Storage is ComptrollerV4Storage {\n  /// @notice The portion of COMP that each contributor receives per block\n  mapping(address => uint256) public compContributorSpeeds;\n\n  /// @notice Last block at which a contributor's COMP rewards have been allocated\n  mapping(address => uint256) public lastContributorBlock;\n}\n\ncontract ComptrollerV6Storage is ComptrollerV5Storage {\n  /// @notice The rate at which comp is distributed to the corresponding borrow market (per block)\n  mapping(address => uint256) public compBorrowSpeeds;\n\n  /// @notice The rate at which comp is distributed to the corresponding supply market (per block)\n  mapping(address => uint256) public compSupplySpeeds;\n}\n\ncontract ComptrollerV7Storage is ComptrollerV6Storage {\n  /// @notice Flag indicating whether the function to fix COMP accruals has been executed (RE: proposal 62 bug)\n  bool public proposal65FixExecuted;\n\n  /// @notice Accounting storage mapping account addresses to how much COMP they owe the protocol.\n  mapping(address => uint256) public compReceivable;\n}\n"
    },
    "contracts/Dammtroller/DammtrollerProxy.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"../ErrorReporter.sol\";\nimport \"./ComptrollerStorage.sol\";\n\n/**\n * @title ComptrollerCore\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * CTokens should reference this contract as their comptroller.\n */\ncontract DammtrollerProxy is UnitrollerAdminStorage, ComptrollerErrorReporter {\n  /**\n   * @notice Emitted when pendingComptrollerImplementation is changed\n   */\n  event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\n\n  /**\n   * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\n   */\n  event NewImplementation(address oldImplementation, address newImplementation);\n\n  /**\n   * @notice Emitted when pendingAdmin is changed\n   */\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n  /**\n   * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  /**\n   * @notice Emitted _compAddress is initially set (when accepting the first comptroller implementation)\n   */\n  event NewCompAddress(address oldAddress, address newAddress);\n\n  constructor() {\n    // Set admin to caller\n    admin = msg.sender;\n  }\n\n  /*** Admin Functions ***/\n  function _setPendingImplementation(address newPendingImplementation) public returns (uint256) {\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n    }\n\n    address oldPendingImplementation = pendingComptrollerImplementation;\n\n    pendingComptrollerImplementation = newPendingImplementation;\n\n    emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n   * @dev Admin function for new implementation to accept it's role as implementation\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptImplementation() public returns (uint256) {\n    // Check caller is pendingImplementation and pendingImplementation  address(0)\n    if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n    }\n\n    // Save current values for inclusion in log\n    address oldImplementation = comptrollerImplementation;\n    address oldPendingImplementation = pendingComptrollerImplementation;\n\n    if (_compAddress == address(0)) {\n      (bool success, bytes memory compAddress) = pendingComptrollerImplementation.call(abi.encodeWithSignature(\"getCompAddress()\"));\n      require(success, \"failed at getCompAddress()\");\n      _compAddress = abi.decode(compAddress, (address));\n      emit NewCompAddress(address(0), _compAddress);\n    }\n\n    comptrollerImplementation = pendingComptrollerImplementation;\n\n    pendingComptrollerImplementation = address(0);\n\n    emit NewImplementation(oldImplementation, comptrollerImplementation);\n    emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @param newPendingAdmin New pending admin.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPendingAdmin(address newPendingAdmin) public returns (uint256) {\n    // Check caller = admin\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n    }\n\n    // Save current value, if any, for inclusion in log\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store pendingAdmin with value newPendingAdmin\n    pendingAdmin = newPendingAdmin;\n\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n   * @dev Admin function for pending admin to accept role and update admin\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptAdmin() public returns (uint256) {\n    // Check caller is pendingAdmin and pendingAdmin  address(0)\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n    }\n\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store admin with value pendingAdmin\n    admin = pendingAdmin;\n\n    // Clear the pending value\n    pendingAdmin = address(0);\n\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * It returns to the external caller whatever the implementation returns\n   * or forwards reverts.\n   */\n  fallback() external payable {\n    // delegate all other functions to current implementation\n    (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n    assembly {\n      let free_mem_ptr := mload(0x40)\n      returndatacopy(free_mem_ptr, 0, returndatasize())\n\n      switch success\n      case 0 {\n        revert(free_mem_ptr, returndatasize())\n      }\n      default {\n        return(free_mem_ptr, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CToken.sol\";\nimport \"./PriceOracle.sol\";\n\ncontract UnitrollerAdminStorage {\n  /**\n   * @notice Administrator for this contract\n   */\n  address public admin;\n\n  /**\n   * @notice Pending administrator for this contract\n   */\n  address public pendingAdmin;\n\n  /**\n   * @notice Active brains of Unitroller\n   */\n  address public comptrollerImplementation;\n\n  /**\n   * @notice Pending brains of Unitroller\n   */\n  address public pendingComptrollerImplementation;\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n  /**\n   * @notice Oracle which gives the price of any given asset\n   */\n  PriceOracle public oracle;\n\n  /**\n   * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n   */\n  uint256 public closeFactorMantissa;\n\n  /**\n   * @notice Multiplier representing the discount on collateral that a liquidator receives\n   */\n  uint256 public liquidationIncentiveMantissa;\n\n  /**\n   * @notice Max number of assets a single account can participate in (borrow or use as collateral)\n   */\n  uint256 public maxAssets;\n\n  /**\n   * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n   */\n  mapping(address => CToken[]) public accountAssets;\n\n  mapping(address => bool) public borrowerArray;\n\n  mapping(address => uint256) public borrowLimit;\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n  struct Market {\n    // Whether or not this market is listed\n    bool isListed;\n    //  Multiplier representing the most one can borrow against their collateral in this market.\n    //  For instance, 0.9 to allow borrowing 90% of collateral value.\n    //  Must be between 0 and 1, and stored as a mantissa.\n    uint256 collateralFactorMantissa;\n    // Per-market mapping of \"accounts in this asset\"\n    mapping(address => bool) accountMembership;\n    // Whether or not this market receives COMP\n    bool isComped;\n  }\n\n  /**\n   * @notice Official mapping of cTokens -> Market metadata\n   * @dev Used e.g. to determine if a market is supported\n   */\n  mapping(address => Market) public markets;\n\n  /**\n   * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n   *  Actions which allow users to remove their own assets cannot be paused.\n   *  Liquidation / seizing / transfer can only be paused globally, not by market.\n   */\n  address public pauseGuardian;\n  bool public _mintGuardianPaused;\n  bool public _borrowGuardianPaused;\n  bool public transferGuardianPaused;\n  bool public seizeGuardianPaused;\n  mapping(address => bool) public mintGuardianPaused;\n  mapping(address => bool) public borrowGuardianPaused;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n  struct CompMarketState {\n    // The market's last updated compBorrowIndex or compSupplyIndex\n    uint224 index;\n    // The block number the index was last updated at\n    uint32 block;\n  }\n\n  /// @notice A list of all markets\n  CToken[] public allMarkets;\n\n  /// @notice The rate at which the flywheel distributes COMP, per block\n  uint256 public compRate;\n\n  /// @notice The portion of compRate that each market currently receives\n  mapping(address => uint256) public compSpeeds;\n\n  /// @notice The COMP market supply state for each market\n  mapping(address => CompMarketState) public compSupplyState;\n\n  /// @notice The COMP market borrow state for each market\n  mapping(address => CompMarketState) public compBorrowState;\n\n  /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP\n  mapping(address => mapping(address => uint256)) public compSupplierIndex;\n\n  /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP\n  mapping(address => mapping(address => uint256)) public compBorrowerIndex;\n\n  /// @notice The COMP accrued but not yet transferred to each user\n  mapping(address => uint256) public compAccrued;\n}\n\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\n  // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n  address public borrowCapGuardian;\n\n  // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n  mapping(address => uint256) public borrowCaps;\n}\n\ncontract ComptrollerV5Storage is ComptrollerV4Storage {\n  /// @notice The portion of COMP that each contributor receives per block\n  mapping(address => uint256) public compContributorSpeeds;\n\n  /// @notice Last block at which a contributor's COMP rewards have been allocated\n  mapping(address => uint256) public lastContributorBlock;\n}\n\ncontract ComptrollerV6Storage is ComptrollerV5Storage {\n  /// @notice The rate at which comp is distributed to the corresponding borrow market (per block)\n  mapping(address => uint256) public compBorrowSpeeds;\n\n  /// @notice The rate at which comp is distributed to the corresponding supply market (per block)\n  mapping(address => uint256) public compSupplySpeeds;\n}\n\ncontract ComptrollerV7Storage is ComptrollerV6Storage {\n  /// @notice Flag indicating whether the function to fix COMP accruals has been executed (RE: proposal 62 bug)\n  bool public proposal65FixExecuted;\n\n  /// @notice Accounting storage mapping account addresses to how much COMP they owe the protocol.\n  mapping(address => uint256) public compReceivable;\n}\n"
    },
    "contracts/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./ErrorReporter.sol\";\nimport \"./ComptrollerStorage.sol\";\n\n/**\n * @title ComptrollerCore\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * CTokens should reference this contract as their comptroller.\n */\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n  /**\n   * @notice Emitted when pendingComptrollerImplementation is changed\n   */\n  event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\n\n  /**\n   * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\n   */\n  event NewImplementation(address oldImplementation, address newImplementation);\n\n  /**\n   * @notice Emitted when pendingAdmin is changed\n   */\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n  /**\n   * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  /**\n   * @notice Emitted _compAddress is initially set (when accepting the first comptroller implementation)\n   */\n  event NewCompAddress(address oldAddress, address newAddress);\n\n  address private _compAddress;\n\n  constructor() {\n    // Set admin to caller\n    admin = msg.sender;\n  }\n\n  /*** Admin Functions ***/\n  function _setPendingImplementation(address newPendingImplementation) public returns (uint256) {\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n    }\n\n    address oldPendingImplementation = pendingComptrollerImplementation;\n\n    pendingComptrollerImplementation = newPendingImplementation;\n\n    emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n   * @dev Admin function for new implementation to accept it's role as implementation\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptImplementation() public returns (uint256) {\n    // Check caller is pendingImplementation and pendingImplementation  address(0)\n    if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n    }\n\n    // Save current values for inclusion in log\n    address oldImplementation = comptrollerImplementation;\n    address oldPendingImplementation = pendingComptrollerImplementation;\n\n    if (_compAddress == address(0)) {\n      (bool success, bytes memory compAddress) = pendingComptrollerImplementation.call(abi.encodeWithSignature(\"getCompAddress()\"));\n      require(success, \"failed at getCompAddress()\");\n      _compAddress = abi.decode(compAddress, (address));\n      emit NewCompAddress(address(0), _compAddress);\n    }\n\n    comptrollerImplementation = pendingComptrollerImplementation;\n\n    pendingComptrollerImplementation = address(0);\n\n    emit NewImplementation(oldImplementation, comptrollerImplementation);\n    emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @param newPendingAdmin New pending admin.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPendingAdmin(address newPendingAdmin) public returns (uint256) {\n    // Check caller = admin\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n    }\n\n    // Save current value, if any, for inclusion in log\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store pendingAdmin with value newPendingAdmin\n    pendingAdmin = newPendingAdmin;\n\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n   * @dev Admin function for pending admin to accept role and update admin\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptAdmin() public returns (uint256) {\n    // Check caller is pendingAdmin and pendingAdmin  address(0)\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n    }\n\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store admin with value pendingAdmin\n    admin = pendingAdmin;\n\n    // Clear the pending value\n    pendingAdmin = address(0);\n\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * It returns to the external caller whatever the implementation returns\n   * or forwards reverts.\n   */\n  fallback() external payable {\n    // delegate all other functions to current implementation\n    (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n    assembly {\n      let free_mem_ptr := mload(0x40)\n      returndatacopy(free_mem_ptr, 0, returndatasize())\n\n      switch success\n      case 0 {\n        revert(free_mem_ptr, returndatasize())\n      }\n      default {\n        return(free_mem_ptr, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/ComptrollerG7.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CToken.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Unitroller.sol\";\nimport \"./Governance/Comp.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n */\ncontract ComptrollerG7 is ComptrollerV5Storage, ComptrollerInterface, ComptrollerErrorReporter, ExponentialNoError {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(CToken cToken);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(CToken cToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(CToken cToken, address account);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(string action, bool pauseState);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPaused(CToken cToken, string action, bool pauseState);\n\n    /// @notice Emitted when a new COMP speed is calculated for a market\n    event CompSpeedUpdated(CToken indexed cToken, uint newSpeed);\n\n    /// @notice Emitted when a new COMP speed is set for a contributor\n    event ContributorCompSpeedUpdated(address indexed contributor, uint newSpeed);\n\n    /// @notice Emitted when COMP is distributed to a supplier\n    event DistributedSupplierComp(CToken indexed cToken, address indexed supplier, uint compDelta, uint compSupplyIndex);\n\n    /// @notice Emitted when COMP is distributed to a borrower\n    event DistributedBorrowerComp(CToken indexed cToken, address indexed borrower, uint compDelta, uint compBorrowIndex);\n\n    /// @notice Emitted when borrow cap for a cToken is changed\n    event NewBorrowCap(CToken indexed cToken, uint newBorrowCap);\n\n    /// @notice Emitted when borrow cap guardian is changed\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n\n    /// @notice Emitted when new borrower is whitelisted\n    event BorrowerWhitelisted(address borrower);\n\n    /// @notice Emitted when borrower's limits are changed\n    event BorrowerLimitChanged(address borrower, uint256 borrowLimit);\n\n    /// @notice Emitted when COMP is granted by admin\n    event CompGranted(address recipient, uint amount);\n\n    /// @notice The initial COMP index for a market\n    uint224 public constant compInitialIndex = 1e36;\n\n    // closeFactorMantissa must be strictly greater than this value\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    // No collateralFactorMantissa may exceed this value\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n    address private _compAddress;\n\n    constructor(address compAddress) public {\n        _compAddress = compAddress;\n        admin = msg.sender;\n    }\n\n    /*** Assets You Are In ***/\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (CToken[] memory) {\n        CToken[] memory assetsIn = accountAssets[account];\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, CToken cToken) external view returns (bool) {\n        return markets[address(cToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] memory cTokens) override public returns (uint[] memory) {\n        uint len = cTokens.length;\n\n        uint[] memory results = new uint[](len);\n        for (uint i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n\n            results[i] = uint(addToMarketInternal(cToken, msg.sender));\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param cToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n    function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\n        Market storage marketToJoin = markets[address(cToken)];\n\n        if (!marketToJoin.isListed) {\n            // market is not listed, cannot join\n            return Error.MARKET_NOT_LISTED;\n        }\n\n        if (marketToJoin.accountMembership[borrower] == true) {\n            // already joined\n            return Error.NO_ERROR;\n        }\n\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(cToken);\n\n        emit MarketEntered(cToken, borrower);\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address cTokenAddress) override external returns (uint) {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = markets[address(cToken)];\n\n        /* Return true if the sender is not already in the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the accounts list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint len = userAssetList.length;\n        uint assetIndex = len;\n        for (uint i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.pop();\n\n        emit MarketExited(cToken, msg.sender);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(address cToken, address minter, uint mintAmount) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n        // Shh - currently unused\n        minter;\n        mintAmount;\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cToken);\n        distributeSupplierComp(cToken, minter);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates mint and reverts on rejection. May emit logs.\n     * @param cToken Asset being minted\n     * @param minter The address minting the tokens\n     * @param actualMintAmount The amount of the underlying asset being minted\n     * @param mintTokens The number of tokens being minted\n     */\n    function mintVerify(address cToken, address minter, uint actualMintAmount, uint mintTokens) override external {\n        // Shh - currently unused\n        cToken;\n        minter;\n        actualMintAmount;\n        mintTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) override external returns (uint) {\n        uint allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n        if (allowed != uint(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cToken);\n        distributeSupplierComp(cToken, redeemer);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal view returns (uint) {\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!markets[cToken].accountMembership[redeemer]) {\n            return uint(Error.NO_ERROR);\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) override external {\n        // Shh - currently unused\n        cToken;\n        redeemer;\n\n        // Require tokens is zero or amount is also zero\n        if (redeemTokens == 0 && redeemAmount > 0) {\n            revert(\"redeemTokens zero\");\n        }\n    }\n\n    function whitelistBorrowerAdd(address borrower) public override returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_BORROWER_LIMIT_CHECK);\n        }\n\n        borrowerArray[borrower] = true;\n        borrowLimit[borrower] = 0;\n\n        emit BorrowerWhitelisted(borrower);\n\n\n        return 0;\n    }\n\n    //Sets the notional limit of borrows for an address\n    function setBorrowerLimits(address borrower, uint256 _borrowLimit) public override returns (uint) {\n        if (msg.sender != admin || borrowerArray[borrower] != true) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_BORROWER_LIMIT_CHECK);\n        }\n        borrowLimit[borrower] = _borrowLimit;\n\n        emit BorrowerLimitChanged(borrower, _borrowLimit);\n\n        return (_borrowLimit);\n    }\n\n    //Returns the notional value of borrows allowed for a borrower\n    function getBorrowerLimits(address borrower) public override view returns (uint256) {\n        require(borrowerArray[borrower] == true, \"Address not permitted to borrow\");\n        return borrowLimit[borrower];\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        if (!markets[cToken].accountMembership[borrower]) {\n            // only cTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == cToken, \"sender must be cToken\");\n\n            // attempt to add borrower to the market\n            Error err = addToMarketInternal(CToken(msg.sender), borrower);\n            if (err != Error.NO_ERROR) {\n                return uint(err);\n            }\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[borrower]);\n        }\n\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n            return uint(Error.PRICE_ERROR);\n        }\n\n        uint borrowCap = borrowCaps[cToken];\n        // Borrow cap of 0 corresponds to unlimited borrowing\n        if (borrowCap != 0) {\n            uint totalBorrows = CToken(cToken).totalBorrows();\n            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n        }\n\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);\n        if (err != Error.NO_ERROR) {\n            return uint(err);\n        }\n\n        if (shortfall > 0) {\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});\n        updateCompBorrowIndex(cToken, borrowIndex);\n        distributeBorrowerComp(cToken, borrower, borrowIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates borrow and reverts on rejection. May emit logs.\n     * @param cToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) override external {\n        // Shh - currently unused\n        cToken;\n        borrower;\n        borrowAmount;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount) override external returns (uint) {\n        // Shh - currently unused\n        payer;\n        borrower;\n        repayAmount;\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});\n        updateCompBorrowIndex(cToken, borrowIndex);\n        distributeBorrowerComp(cToken, borrower, borrowIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\n     * @param cToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint actualRepayAmount,\n        uint borrowerIndex) override external {\n        // Shh - currently unused\n        cToken;\n        payer;\n        borrower;\n        actualRepayAmount;\n        borrowerIndex;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount) override external returns (uint) {\n        // Shh - currently unused\n        liquidator;\n\n        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\n        uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n        uint maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\n        if (repayAmount > maxClose) {\n            return uint(Error.TOO_MUCH_REPAY);\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint actualRepayAmount,\n        uint seizeTokens) override external {\n        // Shh - currently unused\n        cTokenBorrowed;\n        cTokenCollateral;\n        liquidator;\n        borrower;\n        actualRepayAmount;\n        seizeTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n        // Shh - currently unused\n        seizeTokens;\n\n        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n            return uint(Error.COMPTROLLER_MISMATCH);\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cTokenCollateral);\n        distributeSupplierComp(cTokenCollateral, borrower);\n        distributeSupplierComp(cTokenCollateral, liquidator);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates seize and reverts on rejection. May emit logs.\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) override external {\n        // Shh - currently unused\n        cTokenCollateral;\n        cTokenBorrowed;\n        liquidator;\n        borrower;\n        seizeTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!transferGuardianPaused, \"transfer is paused\");\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint allowed = redeemAllowedInternal(cToken, src, transferTokens);\n        if (allowed != uint(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cToken);\n        distributeSupplierComp(cToken, src);\n        distributeSupplierComp(cToken, dst);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates transfer and reverts on rejection. May emit logs.\n     * @param cToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     */\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) override external {\n        // Shh - currently unused\n        cToken;\n        src;\n        dst;\n        transferTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint sumCollateral;\n        uint sumBorrowPlusEffects;\n        uint cTokenBalance;\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n        uint oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(address(0)), 0, 0);\n\n        return (uint(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n        return getHypotheticalAccountLiquidityInternal(account, CToken(address(0)), 0, 0);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address cTokenModify,\n        uint redeemTokens,\n        uint borrowAmount) public view returns (uint, uint, uint) {\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(cTokenModify), redeemTokens, borrowAmount);\n        return (uint(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        CToken cTokenModify,\n        uint redeemTokens,\n        uint borrowAmount) internal view returns (Error, uint, uint) {\n\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint oErr;\n\n        // For each asset the account is in\n        CToken[] memory assets = accountAssets[account];\n\n        /*\n          Start with an assumed collateral value equal to the borrower limit. This sets a baseline for determining\n          whether borrows and redemptions should be allowed\n        */\n        vars.sumCollateral = borrowLimit[account];\n\n        for (uint i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n                return (Error.SNAPSHOT_ERROR, 0, 0);\n            }\n            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n            if (vars.oraclePriceMantissa == 0) {\n                return (Error.PRICE_ERROR, 0, 0);\n            }\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n            // sumCollateral += tokensToDenom * cTokenBalance\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\n\n            // Calculate effects of interacting with cTokenModify\n            if (asset == cTokenModify) {\n                // redeem effect\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\n\n                // borrow effect\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\n            }\n        }\n\n        // These are safe, as the underflow condition is checked first\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n        } else {\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n        }\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param cTokenCollateral The address of the collateral cToken\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint actualRepayAmount) override external view returns (uint, uint) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n            return (uint(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\n        uint seizeTokens;\n        Exp memory numerator;\n        Exp memory denominator;\n        Exp memory ratio;\n\n        numerator = mul_(Exp({mantissa: liquidationIncentiveMantissa}), Exp({mantissa: priceBorrowedMantissa}));\n        denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\n        ratio = div_(numerator, denominator);\n\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n\n        return (uint(Error.NO_ERROR), seizeTokens);\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n      * @notice Sets a new price oracle for the comptroller\n      * @dev Admin function to set a new price oracle\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n        }\n\n        // Track the old oracle for the comptroller\n        PriceOracle oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets the closeFactor used when liquidating borrows\n      * @dev Admin function to set closeFactor\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\n      * @return uint 0=success, otherwise a failure\n      */\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n        // Check caller is admin\n        require(msg.sender == admin, \"only admin can set close factor\");\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets the collateralFactor for a market\n      * @dev Admin function to set per-market collateralFactor\n      * @param cToken The market to set the factor on\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n        }\n\n        // Verify market is listed\n        Market storage market = markets[address(cToken)];\n        if (!market.isListed) {\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n        }\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n        // Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets liquidationIncentive\n      * @dev Admin function to set liquidationIncentive\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n        }\n\n        // Save current value for use in log\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Add the market to the markets mapping and set it as listed\n      * @dev Admin function to set isListed and add support for the market\n      * @param cToken The address of the market (token) to list\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n      */\n    function _supportMarket(CToken cToken) external returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        if (markets[address(cToken)].isListed) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n        // Note that isComped is not in active use anymore\n        Market storage market = markets[address(cToken)];\n        market.isListed = true;\n        market.isComped = false;\n        market.collateralFactorMantissa = 0;\n\n        _addMarketInternal(address(cToken));\n\n        emit MarketListed(cToken);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function _addMarketInternal(address cToken) internal {\n        for (uint i = 0; i < allMarkets.length; i ++) {\n            require(allMarkets[i] != CToken(cToken), \"market already added\");\n        }\n        allMarkets.push(CToken(cToken));\n    }\n\n\n    /**\n      * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\n      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\n      * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n      */\n    function _setMarketBorrowCaps(CToken[] calldata cTokens, uint[] calldata newBorrowCaps) external {\n        require(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\n\n        uint numMarkets = cTokens.length;\n        uint numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for(uint i = 0; i < numMarkets; i++) {\n            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Admin function to change the Borrow Cap Guardian\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\n     */\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n\n        // Save current value for inclusion in log\n        address oldBorrowCapGuardian = borrowCapGuardian;\n\n        // Store borrowCapGuardian with value newBorrowCapGuardian\n        borrowCapGuardian = newBorrowCapGuardian;\n\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n        }\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        mintGuardianPaused[address(cToken)] = state;\n        emit ActionPaused(cToken, \"Mint\", state);\n        return state;\n    }\n\n    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        borrowGuardianPaused[address(cToken)] = state;\n        emit ActionPaused(cToken, \"Borrow\", state);\n        return state;\n    }\n\n    function _setTransferPaused(bool state) public returns (bool) {\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        transferGuardianPaused = state;\n        emit ActionPaused(\"Transfer\", state);\n        return state;\n    }\n\n    function _setSeizePaused(bool state) public returns (bool) {\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        seizeGuardianPaused = state;\n        emit ActionPaused(\"Seize\", state);\n        return state;\n    }\n\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n    }\n\n    /**\n     * @notice Checks caller is admin, or this contract is becoming the new implementation\n     */\n    function adminOrInitializing() internal view returns (bool) {\n        return msg.sender == admin || msg.sender == comptrollerImplementation;\n    }\n\n    /*** Comp Distribution ***/\n\n    /**\n     * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param compSpeed New COMP speed for market\n     */\n    function setCompSpeedInternal(CToken cToken, uint compSpeed) internal {\n        uint currentCompSpeed = compSpeeds[address(cToken)];\n        if (currentCompSpeed != 0) {\n            // note that COMP speed could be set to 0 to halt liquidity rewards for a market\n            Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});\n            updateCompSupplyIndex(address(cToken));\n            updateCompBorrowIndex(address(cToken), borrowIndex);\n        } else if (compSpeed != 0) {\n            // Add the COMP market\n            Market storage market = markets[address(cToken)];\n            require(market.isListed == true, \"comp market is not listed\");\n\n            if (compSupplyState[address(cToken)].index == 0 && compSupplyState[address(cToken)].block == 0) {\n                compSupplyState[address(cToken)] = CompMarketState({\n                    index: compInitialIndex,\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n                });\n            }\n\n            if (compBorrowState[address(cToken)].index == 0 && compBorrowState[address(cToken)].block == 0) {\n                compBorrowState[address(cToken)] = CompMarketState({\n                    index: compInitialIndex,\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n                });\n            }\n        }\n\n        if (currentCompSpeed != compSpeed) {\n            compSpeeds[address(cToken)] = compSpeed;\n            emit CompSpeedUpdated(cToken, compSpeed);\n        }\n    }\n\n    /**\n     * @notice Accrue COMP to the market by updating the supply index\n     * @param cToken The market whose supply index to update\n     */\n    function updateCompSupplyIndex(address cToken) internal {\n        CompMarketState storage supplyState = compSupplyState[cToken];\n        uint supplySpeed = compSpeeds[cToken];\n        uint blockNumber = getBlockNumber();\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\n        if (deltaBlocks > 0 && supplySpeed > 0) {\n            uint supplyTokens = CToken(cToken).totalSupply();\n            uint compAccrued = mul_(deltaBlocks, supplySpeed);\n            Double memory ratio = supplyTokens > 0 ? fraction(compAccrued, supplyTokens) : Double({mantissa: 0});\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n            compSupplyState[cToken] = CompMarketState({\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n            });\n        } else if (deltaBlocks > 0) {\n            supplyState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n        }\n    }\n\n    /**\n     * @notice Accrue COMP to the market by updating the borrow index\n     * @param cToken The market whose borrow index to update\n     */\n    function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex) internal {\n        CompMarketState storage borrowState = compBorrowState[cToken];\n        uint borrowSpeed = compSpeeds[cToken];\n        uint blockNumber = getBlockNumber();\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\n            uint borrowAmount = div_(CToken(cToken).totalBorrows(), marketBorrowIndex);\n            uint compAccrued = mul_(deltaBlocks, borrowSpeed);\n            Double memory ratio = borrowAmount > 0 ? fraction(compAccrued, borrowAmount) : Double({mantissa: 0});\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\n            compBorrowState[cToken] = CompMarketState({\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n            });\n        } else if (deltaBlocks > 0) {\n            borrowState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n        }\n    }\n\n    /**\n     * @notice Calculate COMP accrued by a supplier and possibly transfer it to them\n     * @param cToken The market in which the supplier is interacting\n     * @param supplier The address of the supplier to distribute COMP to\n     */\n    function distributeSupplierComp(address cToken, address supplier) internal {\n        CompMarketState storage supplyState = compSupplyState[cToken];\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\n        Double memory supplierIndex = Double({mantissa: compSupplierIndex[cToken][supplier]});\n        compSupplierIndex[cToken][supplier] = supplyIndex.mantissa;\n\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n            supplierIndex.mantissa = compInitialIndex;\n        }\n\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n        uint supplierTokens = CToken(cToken).balanceOf(supplier);\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\n        uint supplierAccrued = add_(compAccrued[supplier], supplierDelta);\n        compAccrued[supplier] = supplierAccrued;\n        emit DistributedSupplierComp(CToken(cToken), supplier, supplierDelta, supplyIndex.mantissa);\n    }\n\n    /**\n     * @notice Calculate COMP accrued by a borrower and possibly transfer it to them\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\n     * @param cToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute COMP to\n     */\n    function distributeBorrowerComp(address cToken, address borrower, Exp memory marketBorrowIndex) internal {\n        CompMarketState storage borrowState = compBorrowState[cToken];\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\n        Double memory borrowerIndex = Double({mantissa: compBorrowerIndex[cToken][borrower]});\n        compBorrowerIndex[cToken][borrower] = borrowIndex.mantissa;\n\n        if (borrowerIndex.mantissa > 0) {\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n            uint borrowerAmount = div_(CToken(cToken).borrowBalanceStored(borrower), marketBorrowIndex);\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\n            uint borrowerAccrued = add_(compAccrued[borrower], borrowerDelta);\n            compAccrued[borrower] = borrowerAccrued;\n            emit DistributedBorrowerComp(CToken(cToken), borrower, borrowerDelta, borrowIndex.mantissa);\n        }\n    }\n\n    /**\n     * @notice Calculate additional accrued COMP for a contributor since last accrual\n     * @param contributor The address to calculate contributor rewards for\n     */\n    function updateContributorRewards(address contributor) public {\n        uint compSpeed = compContributorSpeeds[contributor];\n        uint blockNumber = getBlockNumber();\n        uint deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\n        if (deltaBlocks > 0 && compSpeed > 0) {\n            uint newAccrued = mul_(deltaBlocks, compSpeed);\n            uint contributorAccrued = add_(compAccrued[contributor], newAccrued);\n\n            compAccrued[contributor] = contributorAccrued;\n            lastContributorBlock[contributor] = blockNumber;\n        }\n    }\n\n    /**\n     * @notice Claim all the comp accrued by holder in all markets\n     * @param holder The address to claim COMP for\n     */\n    function claimComp(address holder) public {\n        return claimComp(holder, allMarkets);\n    }\n\n    /**\n     * @notice Claim all the comp accrued by holder in the specified markets\n     * @param holder The address to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     */\n    function claimComp(address holder, CToken[] memory cTokens) public {\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        claimComp(holders, cTokens, true, true);\n    }\n\n    /**\n     * @notice Claim all comp accrued by the holders\n     * @param holders The addresses to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     * @param borrowers Whether or not to claim COMP earned by borrowing\n     * @param suppliers Whether or not to claim COMP earned by supplying\n     */\n    function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {\n        for (uint i = 0; i < cTokens.length; i++) {\n            CToken cToken = cTokens[i];\n            require(markets[address(cToken)].isListed, \"market must be listed\");\n            if (borrowers == true) {\n                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});\n                updateCompBorrowIndex(address(cToken), borrowIndex);\n                for (uint j = 0; j < holders.length; j++) {\n                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);\n                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);\n                }\n            }\n            if (suppliers == true) {\n                updateCompSupplyIndex(address(cToken));\n                for (uint j = 0; j < holders.length; j++) {\n                    distributeSupplierComp(address(cToken), holders[j]);\n                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Transfer COMP to the user\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n     * @param user The address of the user to transfer COMP to\n     * @param amount The amount of COMP to (possibly) transfer\n     * @return The amount of COMP which was NOT transferred to the user\n     */\n    function grantCompInternal(address user, uint amount) internal returns (uint) {\n        Comp comp = Comp(getCompAddress());\n        uint compRemaining = comp.balanceOf(address(this));\n        if (amount > 0 && amount <= compRemaining) {\n            comp.transfer(user, amount);\n            return 0;\n        }\n        return amount;\n    }\n\n    /*** Comp Distribution Admin ***/\n\n    /**\n     * @notice Transfer COMP to the recipient\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n     * @param recipient The address of the recipient to transfer COMP to\n     * @param amount The amount of COMP to (possibly) transfer\n     */\n    function _grantComp(address recipient, uint amount) public {\n        require(adminOrInitializing(), \"only admin can grant comp\");\n        uint amountLeft = grantCompInternal(recipient, amount);\n        require(amountLeft == 0, \"insufficient comp for grant\");\n        emit CompGranted(recipient, amount);\n    }\n\n    /**\n     * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param compSpeed New COMP speed for market\n     */\n    function _setCompSpeed(CToken cToken, uint compSpeed) public {\n        require(adminOrInitializing(), \"only admin can set comp speed\");\n        setCompSpeedInternal(cToken, compSpeed);\n    }\n\n    /**\n     * @notice Set COMP speed for a single contributor\n     * @param contributor The contributor whose COMP speed to update\n     * @param compSpeed New COMP speed for contributor\n     */\n    function _setContributorCompSpeed(address contributor, uint compSpeed) public {\n        require(adminOrInitializing(), \"only admin can set comp speed\");\n\n        // note that COMP speed could be set to 0 to halt liquidity rewards for a contributor\n        updateContributorRewards(contributor);\n        if (compSpeed == 0) {\n            // release storage\n            delete lastContributorBlock[contributor];\n        } else {\n            lastContributorBlock[contributor] = getBlockNumber();\n        }\n        compContributorSpeeds[contributor] = compSpeed;\n\n        emit ContributorCompSpeedUpdated(contributor, compSpeed);\n    }\n\n    /**\n     * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market.\n     * @return The list of market addresses\n     */\n    function getAllMarkets() public view returns (CToken[] memory) {\n        return allMarkets;\n    }\n\n    function getBlockNumber() public view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @notice Return the address of the COMP token\n     * @return The address of COMP\n     */\n    function getCompAddress() public pure returns (address) {\n        return 0xf9e126C5E047a0Af0aA8EBa426103c1656b6386f;\n    }\n}\n"
    },
    "contracts/CErc20Delegator.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CTokenInterfaces.sol\";\n\n/**\n * @title Compound's CErc20Delegator Contract\n * @notice CTokens which wrap an EIP-20 underlying and delegate to an implementation\n * @author Compound\n */\ncontract CErc20Delegator is CTokenInterface, CErc20Interface, CDelegatorInterface {\n  /**\n   * @notice Construct a new money market\n   * @param underlying_ The address of the underlying asset\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   * @param decimals_ ERC-20 decimal precision of this token\n   * @param admin_ Address of the administrator of this token\n   * @param implementation_ The address of the implementation the contract delegates to\n   * @param becomeImplementationData The encoded args for becomeImplementation\n   */\n  constructor(\n    address underlying_,\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address payable admin_,\n    address implementation_,\n    bytes memory becomeImplementationData\n  ) {\n    // Creator of the contract is admin during initialization\n    admin = payable(msg.sender);\n\n    // First delegate gets to initialize the delegator (i.e. storage contract)\n    delegateTo(\n      implementation_,\n      abi.encodeWithSignature(\n        \"initialize(address,address,address,uint256,string,string,uint8)\",\n        underlying_,\n        comptroller_,\n        interestRateModel_,\n        initialExchangeRateMantissa_,\n        name_,\n        symbol_,\n        decimals_\n      )\n    );\n\n    // New implementations always get set via the settor (post-initialize)\n    _setImplementation(implementation_, false, becomeImplementationData);\n\n    // Set the proper admin now that initialization is done\n    admin = admin_;\n  }\n\n  /**\n   * @notice Called by the admin to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n   */\n  function _setImplementation(\n    address implementation_,\n    bool allowResign,\n    bytes memory becomeImplementationData\n  ) public override {\n    require(msg.sender == admin, \"CErc20Delegator::_setImplementation: Caller must be admin\");\n\n    if (allowResign) {\n      delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n    }\n\n    address oldImplementation = implementation;\n    implementation = implementation_;\n\n    delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n    emit NewImplementation(oldImplementation, implementation);\n  }\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function mint(uint256 mintAmount) external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"mint(uint256)\", mintAmount));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeem(uint256 redeemTokens) external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"redeem(uint256)\", redeemTokens));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to redeem\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlying(uint256 redeemAmount) external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"redeemUnderlying(uint256)\", redeemAmount));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrow(uint256 borrowAmount) external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrow(uint256)\", borrowAmount));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrow(uint256 repayAmount) external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"repayBorrow(uint256)\", repayAmount));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"repayBorrowBehalf(address,uint256)\", borrower, repayAmount));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"liquidateBorrow(address,uint256,address)\", borrower, repayAmount, cTokenCollateral));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 amount) external override returns (bool) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"transfer(address,uint256)\", dst, amount));\n    return abi.decode(data, (bool));\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external override returns (bool) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", src, dst, amount));\n    return abi.decode(data, (bool));\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (-1 means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external override returns (bool) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"approve(address,uint256)\", spender, amount));\n    return abi.decode(data, (bool));\n  }\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(address owner, address spender) external view override returns (uint256) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"allowance(address,address)\", owner, spender));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Get the token balance of the `owner`\n   * @param owner The address of the account to query\n   * @return The number of tokens owned by `owner`\n   */\n  function balanceOf(address owner) external view override returns (uint256) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"balanceOf(address)\", owner));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Get the underlying balance of the `owner`\n   * @dev This also accrues interest in a transaction\n   * @param owner The address of the account to query\n   * @return The amount of underlying owned by `owner`\n   */\n  function balanceOfUnderlying(address owner) external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"balanceOfUnderlying(address)\", owner));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\n   * @dev This is used by comptroller to more efficiently perform liquidity checks.\n   * @param account Address of the account to snapshot\n   * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n   */\n  function getAccountSnapshot(address account)\n    external\n    view\n    override\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"getAccountSnapshot(address)\", account));\n    return abi.decode(data, (uint256, uint256, uint256, uint256));\n  }\n\n  /**\n   * @notice Returns the current per-block borrow interest rate for this cToken\n   * @return The borrow interest rate per block, scaled by 1e18\n   */\n  function borrowRatePerBlock() external view override returns (uint256) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"borrowRatePerBlock()\"));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Returns the current per-block supply interest rate for this cToken\n   * @return The supply interest rate per block, scaled by 1e18\n   */\n  function supplyRatePerBlock() external view override returns (uint256) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"supplyRatePerBlock()\"));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Returns the current total borrows plus accrued interest\n   * @return The total borrows with interest\n   */\n  function totalBorrowsCurrent() external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"totalBorrowsCurrent()\"));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n   * @param account The address whose balance should be calculated after updating borrowIndex\n   * @return The calculated balance\n   */\n  function borrowBalanceCurrent(address account) external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrowBalanceCurrent(address)\", account));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return The calculated balance\n   */\n  function borrowBalanceStored(address account) public view override returns (uint256) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"borrowBalanceStored(address)\", account));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Accrue interest then return the up-to-date exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateCurrent() public override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"exchangeRateCurrent()\"));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStored() public view override returns (uint256) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"exchangeRateStored()\"));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Get cash balance of this cToken in the underlying asset\n   * @return The quantity of underlying asset owned by this contract\n   */\n  function getCash() external view override returns (uint256) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"getCash()\"));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Applies accrued interest to total borrows and reserves.\n   * @dev This calculates interest accrued from the last checkpointed block\n   *      up to the current block and writes new checkpoint to storage.\n   */\n  function accrueInterest() public override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"accrueInterest()\"));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Will fail unless called by another cToken during the process of liquidation.\n   *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of cTokens to seize\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"seize(address,address,uint256)\", liquidator, borrower, seizeTokens));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n   * @param token The address of the ERC-20 token to sweep\n   */\n  function sweepToken(EIP20NonStandardInterface token) external override {\n    delegateToImplementation(abi.encodeWithSignature(\"sweepToken(address)\", token));\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @param newPendingAdmin New pending admin.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPendingAdmin(address payable newPendingAdmin) external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setPendingAdmin(address)\", newPendingAdmin));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Sets a new comptroller for the market\n   * @dev Admin function to set a new comptroller\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setComptroller(ComptrollerInterface newComptroller) public override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setComptroller(address)\", newComptroller));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n   * @dev Admin function to accrue interest and set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setReserveFactor(uint256)\", newReserveFactorMantissa));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n   * @dev Admin function for pending admin to accept role and update admin\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptAdmin() external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_acceptAdmin()\"));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Accrues interest and adds reserves by transferring from admin\n   * @param addAmount Amount of reserves to add\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addReserves(uint256 addAmount) external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_addReserves(uint256)\", addAmount));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring to admin\n   * @param reduceAmount Amount of reduction to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _reduceReserves(uint256 reduceAmount) external override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_reduceReserves(uint256)\", reduceAmount));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh\n   * @dev Admin function to accrue interest and update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) public override returns (uint256) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel));\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Internal method to delegate execution to another contract\n   * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n   * @param callee The contract to delegatecall\n   * @param data The raw data to delegatecall\n   * @return The returned bytes from the delegatecall\n   */\n  function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n    (bool success, bytes memory returnData) = callee.delegatecall(data);\n    assembly {\n      if eq(success, 0) {\n        revert(add(returnData, 0x20), returndatasize())\n      }\n    }\n    return returnData;\n  }\n\n  /**\n   * @notice Delegates execution to the implementation contract\n   * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n   * @param data The raw data to delegatecall\n   * @return The returned bytes from the delegatecall\n   */\n  function delegateToImplementation(bytes memory data) public returns (bytes memory) {\n    return delegateTo(implementation, data);\n  }\n\n  /**\n   * @notice Delegates execution to an implementation contract\n   * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n   *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n   * @param data The raw data to delegatecall\n   * @return The returned bytes from the delegatecall\n   */\n  function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n    (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n    assembly {\n      if eq(success, 0) {\n        revert(add(returnData, 0x20), returndatasize())\n      }\n    }\n    return abi.decode(returnData, (bytes));\n  }\n\n  /**\n   * @notice Delegates execution to an implementation contract\n   * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n   */\n  fallback() external payable {\n    require(msg.value == 0, \"CErc20Delegator:fallback: cannot send value to fallback\");\n\n    // delegate all other functions to current implementation\n    (bool success, ) = implementation.delegatecall(msg.data);\n\n    assembly {\n      let free_mem_ptr := mload(0x40)\n      returndatacopy(free_mem_ptr, 0, returndatasize())\n\n      switch success\n      case 0 {\n        revert(free_mem_ptr, returndatasize())\n      }\n      default {\n        return(free_mem_ptr, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/WhitePaperInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's WhitePaperInterestRateModel Contract\n * @author Compound\n * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper\n */\ncontract WhitePaperInterestRateModel is InterestRateModel {\n  event NewInterestParams(uint256 baseRatePerBlock, uint256 multiplierPerBlock);\n\n  uint256 private constant BASE = 1e18;\n\n  /**\n   * @notice The approximate number of blocks per year that is assumed by the interest rate model\n   */\n  uint256 public constant blocksPerYear = 2629800;\n\n  /**\n   * @notice The multiplier of utilization rate that gives the slope of the interest rate\n   */\n  uint256 public multiplierPerBlock;\n\n  /**\n   * @notice The base interest rate which is the y-intercept when utilization rate is 0\n   */\n  uint256 public baseRatePerBlock;\n\n  /**\n   * @notice Construct an interest rate model\n   * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n   * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n   */\n  constructor(uint256 baseRatePerYear, uint256 multiplierPerYear) public {\n    baseRatePerBlock = baseRatePerYear / blocksPerYear;\n    multiplierPerBlock = multiplierPerYear / blocksPerYear;\n\n    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock);\n  }\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market (currently unused)\n   * @return The utilization rate as a mantissa between [0, BASE]\n   */\n  function utilizationRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public pure returns (uint256) {\n    // Utilization rate is 0 when there are no borrows\n    if (borrows == 0) {\n      return 0;\n    }\n\n    return (borrows * BASE) / (cash + borrows - reserves);\n  }\n\n  /**\n   * @notice Calculates the current borrow rate per block, with the error code expected by the market\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @return The borrow rate percentage per block as a mantissa (scaled by BASE)\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public view override returns (uint256) {\n    uint256 ur = utilizationRate(cash, borrows, reserves);\n    return ((ur * multiplierPerBlock) / BASE) + baseRatePerBlock;\n  }\n\n  /**\n   * @notice Calculates the current supply rate per block\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @param reserveFactorMantissa The current reserve factor for the market\n   * @return The supply rate percentage per block as a mantissa (scaled by BASE)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) public view override returns (uint256) {\n    uint256 oneMinusReserveFactor = BASE - reserveFactorMantissa;\n    uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\n    uint256 rateToPool = (borrowRate * oneMinusReserveFactor) / BASE;\n    return (utilizationRate(cash, borrows, reserves) * rateToPool) / BASE;\n  }\n}\n"
    },
    "contracts/JumpRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./BaseJumpRateModelV2.sol\";\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's JumpRateModel Contract V2 for V2 cTokens\n * @author Arr00\n * @notice Supports only for V2 cTokens\n */\ncontract JumpRateModelV2 is InterestRateModel, BaseJumpRateModelV2 {\n  /**\n   * @notice Calculates the current borrow rate per block\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) external view override returns (uint256) {\n    return getBorrowRateInternal(cash, borrows, reserves);\n  }\n\n  constructor(\n    uint256 baseRatePerYear,\n    uint256 multiplierPerYear,\n    uint256 jumpMultiplierPerYear,\n    uint256 kink_,\n    address owner_\n  ) public BaseJumpRateModelV2(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_, owner_) {}\n}\n"
    },
    "contracts/BaseJumpRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Logic for Compound's JumpRateModel Contract V2.\n * @author Compound (modified by Dharma Labs, refactored by Arr00)\n * @notice Version 2 modifies Version 1 by enabling updateable parameters.\n */\nabstract contract BaseJumpRateModelV2 is InterestRateModel {\n  event NewInterestParams(uint256 baseRatePerBlock, uint256 multiplierPerBlock, uint256 jumpMultiplierPerBlock, uint256 kink);\n\n  uint256 private constant BASE = 1e18;\n\n  /**\n   * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\n   */\n  address public owner;\n\n  /**\n   * @notice The approximate number of blocks per year that is assumed by the interest rate model\n   */\n  uint256 public constant blocksPerYear = 2628000;\n\n  /**\n   * @notice The multiplier of utilization rate that gives the slope of the interest rate\n   */\n  uint256 public multiplierPerBlock;\n\n  /**\n   * @notice The base interest rate which is the y-intercept when utilization rate is 0\n   */\n  uint256 public baseRatePerBlock;\n\n  /**\n   * @notice The multiplierPerBlock after hitting a specified utilization point\n   */\n  uint256 public jumpMultiplierPerBlock;\n\n  /**\n   * @notice The utilization point at which the jump multiplier is applied\n   */\n  uint256 public kink;\n\n  /**\n   * @notice Construct an interest rate model\n   * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n   * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n   * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n   * @param kink_ The utilization point at which the jump multiplier is applied\n   * @param owner_ The address of the owner, i.e. the Timelock contract (which has the ability to update parameters directly)\n   */\n  constructor(\n    uint256 baseRatePerYear,\n    uint256 multiplierPerYear,\n    uint256 jumpMultiplierPerYear,\n    uint256 kink_,\n    address owner_\n  ) internal {\n    owner = owner_;\n\n    updateJumpRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\n  }\n\n  /**\n   * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\n   * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n   * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n   * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n   * @param kink_ The utilization point at which the jump multiplier is applied\n   */\n  function updateJumpRateModel(\n    uint256 baseRatePerYear,\n    uint256 multiplierPerYear,\n    uint256 jumpMultiplierPerYear,\n    uint256 kink_\n  ) external virtual {\n    require(msg.sender == owner, \"only the owner may call this function.\");\n\n    updateJumpRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\n  }\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market (currently unused)\n   * @return The utilization rate as a mantissa between [0, BASE]\n   */\n  function utilizationRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public pure returns (uint256) {\n    // Utilization rate is 0 when there are no borrows\n    if (borrows == 0) {\n      return 0;\n    }\n\n    return (borrows * BASE) / (cash + borrows - reserves);\n  }\n\n  /**\n   * @notice Calculates the current borrow rate per block, with the error code expected by the market\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @return The borrow rate percentage per block as a mantissa (scaled by BASE)\n   */\n  function getBorrowRateInternal(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) internal view returns (uint256) {\n    uint256 util = utilizationRate(cash, borrows, reserves);\n\n    if (util <= kink) {\n      return ((util * multiplierPerBlock) / BASE) + baseRatePerBlock;\n    } else {\n      uint256 normalRate = ((kink * multiplierPerBlock) / BASE) + baseRatePerBlock;\n      uint256 excessUtil = util - kink;\n      return ((excessUtil * jumpMultiplierPerBlock) / BASE) + normalRate;\n    }\n  }\n\n  /**\n   * @notice Calculates the current supply rate per block\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @param reserveFactorMantissa The current reserve factor for the market\n   * @return The supply rate percentage per block as a mantissa (scaled by BASE)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) public view virtual override returns (uint256) {\n    uint256 oneMinusReserveFactor = BASE - reserveFactorMantissa;\n    uint256 borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n    uint256 rateToPool = (borrowRate * oneMinusReserveFactor) / BASE;\n    return (utilizationRate(cash, borrows, reserves) * rateToPool) / BASE;\n  }\n\n  /**\n   * @notice Internal function to update the parameters of the interest rate model\n   * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n   * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n   * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n   * @param kink_ The utilization point at which the jump multiplier is applied\n   */\n  function updateJumpRateModelInternal(\n    uint256 baseRatePerYear,\n    uint256 multiplierPerYear,\n    uint256 jumpMultiplierPerYear,\n    uint256 kink_\n  ) internal {\n    baseRatePerBlock = baseRatePerYear / blocksPerYear;\n    multiplierPerBlock = (multiplierPerYear * BASE) / (blocksPerYear * kink_);\n    jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;\n    kink = kink_;\n\n    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n  }\n}\n"
    },
    "contracts/JumpRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's JumpRateModel Contract\n * @author Compound\n */\ncontract JumpRateModel is InterestRateModel {\n  event NewInterestParams(uint256 baseRatePerBlock, uint256 multiplierPerBlock, uint256 jumpMultiplierPerBlock, uint256 kink);\n\n  uint256 private constant BASE = 1e18;\n\n  /**\n   * @notice The approximate number of blocks per year that is assumed by the interest rate model\n   */\n  uint256 public constant blocksPerYear = 2629800;\n\n  /**\n   * @notice The multiplier of utilization rate that gives the slope of the interest rate\n   */\n  uint256 public multiplierPerBlock;\n\n  /**\n   * @notice The base interest rate which is the y-intercept when utilization rate is 0\n   */\n  uint256 public baseRatePerBlock;\n\n  /**\n   * @notice The multiplierPerBlock after hitting a specified utilization point\n   */\n  uint256 public jumpMultiplierPerBlock;\n\n  /**\n   * @notice The utilization point at which the jump multiplier is applied\n   */\n  uint256 public kink;\n\n  /**\n   * @notice Construct an interest rate model\n   * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n   * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n   * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n   * @param kink_ The utilization point at which the jump multiplier is applied\n   */\n  constructor(\n    uint256 baseRatePerYear,\n    uint256 multiplierPerYear,\n    uint256 jumpMultiplierPerYear,\n    uint256 kink_\n  ) public {\n    baseRatePerBlock = baseRatePerYear / blocksPerYear;\n    multiplierPerBlock = multiplierPerYear / blocksPerYear;\n    jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;\n    kink = kink_;\n\n    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n  }\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market (currently unused)\n   * @return The utilization rate as a mantissa between [0, BASE]\n   */\n  function utilizationRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public pure returns (uint256) {\n    // Utilization rate is 0 when there are no borrows\n    if (borrows == 0) {\n      return 0;\n    }\n\n    return (borrows * BASE) / (cash + borrows - reserves);\n  }\n\n  /**\n   * @notice Calculates the current borrow rate per block, with the error code expected by the market\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @return The borrow rate percentage per block as a mantissa (scaled by BASE)\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public view override returns (uint256) {\n    uint256 util = utilizationRate(cash, borrows, reserves);\n\n    if (util <= kink) {\n      return ((util * multiplierPerBlock) / BASE) + baseRatePerBlock;\n    } else {\n      uint256 normalRate = ((kink * multiplierPerBlock) / BASE) + baseRatePerBlock;\n      uint256 excessUtil = util - kink;\n      return ((excessUtil * jumpMultiplierPerBlock) / BASE) + normalRate;\n    }\n  }\n\n  /**\n   * @notice Calculates the current supply rate per block\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @param reserveFactorMantissa The current reserve factor for the market\n   * @return The supply rate percentage per block as a mantissa (scaled by BASE)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) public view override returns (uint256) {\n    uint256 oneMinusReserveFactor = BASE - reserveFactorMantissa;\n    uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\n    uint256 rateToPool = (borrowRate * oneMinusReserveFactor) / BASE;\n    return (utilizationRate(cash, borrows, reserves) * rateToPool) / BASE;\n  }\n}\n"
    },
    "contracts/CEther.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CToken.sol\";\n\n/**\n * @title Compound's CEther Contract\n * @notice CToken which wraps Ether\n * @author Compound\n */\ncontract CEther is CToken {\n  /**\n   * @notice Construct a new CEther money market\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   * @param decimals_ ERC-20 decimal precision of this token\n   * @param admin_ Address of the administrator of this token\n   */\n  constructor(\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address payable admin_\n  ) {\n    // Creator of the contract is admin during initialization\n    admin = payable(msg.sender);\n\n    initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n    // Set the proper admin now that initialization is done\n    admin = admin_;\n  }\n\n  /*** User Interface ***/\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Reverts upon any failure\n   */\n  function mint() external payable {\n    mintInternal(msg.value);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeem(uint256 redeemTokens) external returns (uint256) {\n    redeemInternal(redeemTokens);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to redeem\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {\n    redeemUnderlyingInternal(redeemAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrow(uint256 borrowAmount) external returns (uint256) {\n    borrowInternal(borrowAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @dev Reverts upon any failure\n   */\n  function repayBorrow() external payable {\n    repayBorrowInternal(msg.value);\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @dev Reverts upon any failure\n   * @param borrower the account with the debt being payed off\n   */\n  function repayBorrowBehalf(address borrower) external payable {\n    repayBorrowBehalfInternal(borrower, msg.value);\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @dev Reverts upon any failure\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   */\n  function liquidateBorrow(address borrower, CToken cTokenCollateral) external payable {\n    liquidateBorrowInternal(borrower, msg.value, cTokenCollateral);\n  }\n\n  /**\n   * @notice The sender adds to reserves.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addReserves() external payable returns (uint256) {\n    return _addReservesInternal(msg.value);\n  }\n\n  /**\n   * @notice Send Ether to CEther to mint\n   */\n  receive() external payable {\n    mintInternal(msg.value);\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of Ether, before this message\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of Ether owned by this contract\n   */\n  function getCashPrior() internal view override returns (uint256) {\n    return address(this).balance - msg.value;\n  }\n\n  /**\n   * @notice Perform the actual transfer in, which is a no-op\n   * @param from Address sending the Ether\n   * @param amount Amount of Ether being sent\n   * @return The actual amount of Ether transferred\n   */\n  function doTransferIn(address from, uint256 amount) internal override returns (uint256) {\n    // Sanity checks\n    require(msg.sender == from, \"sender mismatch\");\n    require(msg.value == amount, \"value mismatch\");\n    return amount;\n  }\n\n  function doTransferOut(address payable to, uint256 amount) internal virtual override {\n    /* Send the Ether, with minimal gas and revert on failure */\n    to.transfer(amount);\n  }\n}\n"
    },
    "contracts/Maximillion.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CEther.sol\";\n\n/**\n * @title Compound's Maximillion Contract\n * @author Compound\n */\ncontract Maximillion {\n  /**\n   * @notice The default cEther market to repay in\n   */\n  CEther public cEther;\n\n  /**\n   * @notice Construct a Maximillion to repay max in a CEther market\n   */\n  constructor(CEther cEther_) public {\n    cEther = cEther_;\n  }\n\n  /**\n   * @notice msg.sender sends Ether to repay an account's borrow in the cEther market\n   * @dev The provided Ether is applied towards the borrow balance, any excess is refunded\n   * @param borrower The address of the borrower account to repay on behalf of\n   */\n  function repayBehalf(address borrower) public payable {\n    repayBehalfExplicit(borrower, cEther);\n  }\n\n  /**\n   * @notice msg.sender sends Ether to repay an account's borrow in a cEther market\n   * @dev The provided Ether is applied towards the borrow balance, any excess is refunded\n   * @param borrower The address of the borrower account to repay on behalf of\n   * @param cEther_ The address of the cEther contract to repay in\n   */\n  function repayBehalfExplicit(address borrower, CEther cEther_) public payable {\n    uint256 received = msg.value;\n    uint256 borrows = cEther_.borrowBalanceCurrent(borrower);\n    if (received > borrows) {\n      cEther_.repayBorrowBehalf{ value: borrows }(borrower);\n      payable(msg.sender).transfer(received - borrows);\n    } else {\n      cEther_.repayBorrowBehalf{ value: received }(borrower);\n    }\n  }\n}\n"
    },
    "contracts/Reservoir.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title Reservoir Contract\n * @notice Distributes a token to a different contract at a fixed rate.\n * @dev This contract must be poked via the `drip()` function every so often.\n * @author Compound\n */\ncontract Reservoir {\n  /// @notice The block number when the Reservoir started (immutable)\n  uint256 public dripStart;\n\n  /// @notice Tokens per block that to drip to target (immutable)\n  uint256 public dripRate;\n\n  /// @notice Reference to token to drip (immutable)\n  EIP20Interface public token;\n\n  /// @notice Target to receive dripped tokens (immutable)\n  address public target;\n\n  /// @notice Amount that has already been dripped\n  uint256 public dripped;\n\n  /**\n   * @notice Constructs a Reservoir\n   * @param dripRate_ Numer of tokens per block to drip\n   * @param token_ The token to drip\n   * @param target_ The recipient of dripped tokens\n   */\n  constructor(\n    uint256 dripRate_,\n    EIP20Interface token_,\n    address target_\n  ) public {\n    dripStart = block.number;\n    dripRate = dripRate_;\n    token = token_;\n    target = target_;\n    dripped = 0;\n  }\n\n  /**\n   * @notice Drips the maximum amount of tokens to match the drip rate since inception\n   * @dev Note: this will only drip up to the amount of tokens available.\n   * @return The amount of tokens dripped in this call\n   */\n  function drip() public returns (uint256) {\n    // First, read storage into memory\n    EIP20Interface token_ = token;\n    uint256 reservoirBalance_ = token_.balanceOf(address(this)); // TODO: Verify this is a static call\n    uint256 dripRate_ = dripRate;\n    uint256 dripStart_ = dripStart;\n    uint256 dripped_ = dripped;\n    address target_ = target;\n    uint256 blockNumber_ = block.number;\n\n    // Next, calculate intermediate values\n    uint256 dripTotal_ = mul(dripRate_, blockNumber_ - dripStart_, \"dripTotal overflow\");\n    uint256 deltaDrip_ = sub(dripTotal_, dripped_, \"deltaDrip underflow\");\n    uint256 toDrip_ = min(reservoirBalance_, deltaDrip_);\n    uint256 drippedNext_ = add(dripped_, toDrip_, \"tautological\");\n\n    // Finally, write new `dripped` value and transfer tokens to target\n    dripped = drippedNext_;\n    token_.transfer(target_, toDrip_);\n\n    return toDrip_;\n  }\n\n  /* Internal helper functions for safe math */\n\n  function add(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    uint256 c;\n    unchecked {\n      c = a + b;\n    }\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n    return c;\n  }\n\n  function mul(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c;\n    unchecked {\n      c = a * b;\n    }\n    require(c / a == b, errorMessage);\n    return c;\n  }\n\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a <= b) {\n      return a;\n    } else {\n      return b;\n    }\n  }\n}\n\nimport \"./EIP20Interface.sol\";\n"
    },
    "contracts/Faucet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./EIP20Interface.sol\";\nimport \"./openzeppelin/Ownable.sol\";\n\ncontract Faucet is Ownable {\n  event Funded(address fundee, EIP20Interface token, uint256 amount);\n  event SkippingFundingAlreadyFunded(address fundee, EIP20Interface token, uint256 currentBalance);\n  event SkippingFundingFaucetDry(address fundee, EIP20Interface token, uint256 faucetBalance);\n  mapping(address => bool) public fundees;\n  EIP20Interface[] public supportedTokens;\n\n  constructor(EIP20Interface[] memory tokens) {\n    supportedTokens = tokens;\n  }\n\n  function tap() external {\n    address fundee = tx.origin;\n    require(!fundees[fundee], \"account has already been funded\");\n    fundees[fundee] = true;\n    _seed(fundee, supportedTokens);\n  }\n\n  /*\n    Allows Faucet owner to fund a fundee that has previously been funded (and therefor won't be\n    to call `tap()`)\n  */\n  function seed(address fundee) external onlyOwner {\n    _seed(fundee, supportedTokens);\n  }\n\n  function _seed(address fundee, EIP20Interface[] memory tokens) internal {\n    for (uint i = 0; i < tokens.length; i += 1) {\n      EIP20Interface token = tokens[i];\n      /*\n        Don't attempt to fund USDT; it isn't ERC20 conformant and will break the seed call because\n        transfer doesn't return a bool\n      */\n      if (\n        keccak256(abi.encodePacked(token.symbol())) != keccak256(abi.encodePacked(\"USDT\"))\n      ) {\n\n        uint256 amount = 1000 * (10 ** (token.decimals()));\n        uint256 faucetBalance = token.balanceOf(address(this));\n        uint256 fundeeBalance = token.balanceOf(fundee);\n        if (fundeeBalance >= amount) {\n          emit SkippingFundingAlreadyFunded(fundee, token, fundeeBalance);\n        } else if (faucetBalance < amount) {\n          emit SkippingFundingFaucetDry(fundee, token, faucetBalance);\n        } else {\n          require(token.transfer(fundee, amount), \"something went wrong with token transfer\");\n          emit Funded(fundee, token, amount);\n        }\n\n      }\n    }\n  }\n}"
    },
    "contracts/CErc20Immutable.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CErc20.sol\";\n\n/**\n * @title Compound's CErc20Immutable Contract\n * @notice CTokens which wrap an EIP-20 underlying and are immutable\n * @author Compound\n */\ncontract CErc20Immutable is CErc20 {\n  /**\n   * @notice Construct a new money market\n   * @param underlying_ The address of the underlying asset\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   * @param decimals_ ERC-20 decimal precision of this token\n   * @param admin_ Address of the administrator of this token\n   */\n  constructor(\n    address underlying_,\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address payable admin_\n  ) {\n    // Creator of the contract is admin during initialization\n    admin = payable(msg.sender);\n\n    // Initialize the market\n    initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n    // Set the proper admin now that initialization is done\n    admin = admin_;\n  }\n}\n"
    },
    "contracts/CErc20Delegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CErc20.sol\";\n\n/**\n * @title Compound's CErc20Delegate Contract\n * @notice CTokens which wrap an EIP-20 underlying and are delegated to\n * @author Compound\n */\ncontract CErc20Delegate is CErc20, CDelegateInterface {\n  /**\n   * @notice Construct an empty delegate\n   */\n  constructor() {}\n\n  /**\n   * @notice Called by the delegator on a delegate to initialize it for duty\n   * @param data The encoded bytes data for any initialization\n   */\n  function _becomeImplementation(bytes memory data) public virtual override {\n    // Shh -- currently unused\n    data;\n\n    // Shh -- we don't ever want this hook to be marked pure\n    if (false) {\n      implementation = address(0);\n    }\n\n    require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n  }\n\n  /**\n   * @notice Called by the delegator on a delegate to forfeit its responsibility\n   */\n  function _resignImplementation() public virtual override {\n    // Shh -- we don't ever want this hook to be marked pure\n    if (false) {\n      implementation = address(0);\n    }\n\n    require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n  }\n}\n"
    },
    "contracts/CDaiDelegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CErc20Delegate.sol\";\n\n/**\n * @title Compound's CDai Contract\n * @notice CToken which wraps Multi-Collateral DAI\n * @author Compound\n */\ncontract CDaiDelegate is CErc20Delegate {\n  /**\n   * @notice DAI adapter address\n   */\n  address public daiJoinAddress;\n\n  /**\n   * @notice DAI Savings Rate (DSR) pot address\n   */\n  address public potAddress;\n\n  /**\n   * @notice DAI vat address\n   */\n  address public vatAddress;\n\n  /**\n   * @notice Delegate interface to become the implementation\n   * @param data The encoded arguments for becoming\n   */\n  function _becomeImplementation(bytes memory data) public override {\n    require(msg.sender == admin, \"only the admin may initialize the implementation\");\n\n    (address daiJoinAddress_, address potAddress_) = abi.decode(data, (address, address));\n    return _becomeImplementation(daiJoinAddress_, potAddress_);\n  }\n\n  /**\n   * @notice Explicit interface to become the implementation\n   * @param daiJoinAddress_ DAI adapter address\n   * @param potAddress_ DAI Savings Rate (DSR) pot address\n   */\n  function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {\n    // Get dai and vat and sanity check the underlying\n    DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\n    PotLike pot = PotLike(potAddress_);\n    GemLike dai = daiJoin.dai();\n    VatLike vat = daiJoin.vat();\n    require(address(dai) == underlying, \"DAI must be the same as underlying\");\n\n    // Remember the relevant addresses\n    daiJoinAddress = daiJoinAddress_;\n    potAddress = potAddress_;\n    vatAddress = address(vat);\n\n    // Approve moving our DAI into the vat through daiJoin\n    dai.approve(daiJoinAddress, type(uint256).max);\n\n    // Approve the pot to transfer our funds within the vat\n    vat.hope(potAddress);\n    vat.hope(daiJoinAddress);\n\n    // Accumulate DSR interest -- must do this in order to doTransferIn\n    pot.drip();\n\n    // Transfer all cash in (doTransferIn does this regardless of amount)\n    doTransferIn(address(this), 0);\n  }\n\n  /**\n   * @notice Delegate interface to resign the implementation\n   */\n  function _resignImplementation() public override {\n    require(msg.sender == admin, \"only the admin may abandon the implementation\");\n\n    // Transfer all cash out of the DSR - note that this relies on self-transfer\n    DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n    PotLike pot = PotLike(potAddress);\n    VatLike vat = VatLike(vatAddress);\n\n    // Accumulate interest\n    pot.drip();\n\n    // Calculate the total amount in the pot, and move it out\n    uint256 pie = pot.pie(address(this));\n    pot.exit(pie);\n\n    // Checks the actual balance of DAI in the vat after the pot exit\n    uint256 bal = vat.dai(address(this));\n\n    // Remove our whole balance\n    daiJoin.exit(address(this), bal / RAY);\n  }\n\n  /*** CToken Overrides ***/\n\n  /**\n   * @notice Accrues DSR then applies accrued interest to total borrows and reserves\n   * @dev This calculates interest accrued from the last checkpointed block\n   *      up to the current block and writes new checkpoint to storage.\n   */\n  function accrueInterest() public override returns (uint256) {\n    // Accumulate DSR interest\n    PotLike(potAddress).drip();\n\n    // Accumulate CToken interest\n    return super.accrueInterest();\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying tokens owned by this contract\n   */\n  function getCashPrior() internal view override returns (uint256) {\n    PotLike pot = PotLike(potAddress);\n    uint256 pie = pot.pie(address(this));\n    return mul(pot.chi(), pie) / RAY;\n  }\n\n  /**\n   * @notice Transfer the underlying to this contract and sweep into DSR pot\n   * @param from Address to transfer funds from\n   * @param amount Amount of underlying to transfer\n   * @return The actual amount that is transferred\n   */\n  function doTransferIn(address from, uint256 amount) internal override returns (uint256) {\n    // Read from storage once\n    address underlying_ = underlying;\n    // Perform the EIP-20 transfer in\n    EIP20Interface token = EIP20Interface(underlying_);\n    require(token.transferFrom(from, address(this), amount), \"unexpected EIP-20 transfer in return\");\n\n    DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n    GemLike dai = GemLike(underlying_);\n    PotLike pot = PotLike(potAddress);\n    VatLike vat = VatLike(vatAddress);\n\n    // Convert all our DAI to internal DAI in the vat\n    daiJoin.join(address(this), dai.balanceOf(address(this)));\n\n    // Checks the actual balance of DAI in the vat after the join\n    uint256 bal = vat.dai(address(this));\n\n    // Calculate the percentage increase to th pot for the entire vat, and move it in\n    // Note: We may leave a tiny bit of DAI in the vat...but we do the whole thing every time\n    uint256 pie = bal / pot.chi();\n    pot.join(pie);\n\n    return amount;\n  }\n\n  /**\n   * @notice Transfer the underlying from this contract, after sweeping out of DSR pot\n   * @param to Address to transfer funds to\n   * @param amount Amount of underlying to transfer\n   */\n  function doTransferOut(address payable to, uint256 amount) internal override {\n    DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n    PotLike pot = PotLike(potAddress);\n\n    // Calculate the percentage decrease from the pot, and move that much out\n    // Note: Use a slightly larger pie size to ensure that we get at least amount in the vat\n    uint256 pie = add(mul(amount, RAY) / pot.chi(), 1);\n    pot.exit(pie);\n\n    daiJoin.exit(to, amount);\n  }\n\n  /*** Maker Internals ***/\n\n  uint256 constant RAY = 10**27;\n\n  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    require((z = x + y) >= x, \"add-overflow\");\n  }\n\n  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n  }\n}\n\n/*** Maker Interfaces ***/\n\ninterface PotLike {\n  function chi() external view returns (uint256);\n\n  function pie(address) external view returns (uint256);\n\n  function drip() external returns (uint256);\n\n  function join(uint256) external;\n\n  function exit(uint256) external;\n}\n\ninterface GemLike {\n  function approve(address, uint256) external;\n\n  function balanceOf(address) external view returns (uint256);\n\n  function transferFrom(\n    address,\n    address,\n    uint256\n  ) external returns (bool);\n}\n\ninterface VatLike {\n  function dai(address) external view returns (uint256);\n\n  function hope(address) external;\n}\n\ninterface DaiJoinLike {\n  function vat() external returns (VatLike);\n\n  function dai() external returns (GemLike);\n\n  function join(address, uint256) external payable;\n\n  function exit(address, uint256) external;\n}\n"
    },
    "contracts/DAMM/Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../openzeppelin/Ownable.sol\";\nimport \"../openzeppelin/ERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\n\n// from and to are addresses of tokens who have the same decimals\ncontract Swap is Ownable, ReentrancyGuard {\n    ERC20 _fromToken;\n    ERC20 _toToken;\n\n    constructor(ERC20 fromToken, ERC20 toToken) {\n        _fromToken = fromToken;\n        _toToken = toToken;\n    }\n\n    function swap(uint256 amount) nonReentrant external {\n        address user = msg.sender;\n        uint256 allowance = _fromToken.allowance(user, address(this));\n        require(amount <= allowance, \"User has not given swap contract spend approval\");\n        uint256 selfBalanceToToken = _toToken.balanceOf(address(this));\n        require(amount <= selfBalanceToToken, \"Not enough liquidity\");\n        require(_fromToken.transferFrom(user, address(this), amount), \"Could not transfer user's token to swap contract\");\n        require(_toToken.transfer(user, amount), \"Swap contract could not transfer token to user\");\n    }\n\n    function withdrawFrom() onlyOwner external {\n        uint256 balance = _fromToken.balanceOf(address(this));\n        require(_fromToken.transfer(this.owner(), balance), \"Admin could not withdraw FromToken\");\n    }\n\n    function withdrawTo() onlyOwner external {\n        uint256 balance = _toToken.balanceOf(address(this));\n        require(_toToken.transfer(this.owner(), balance), \"Admin could not withdraw ToToken\");\n    }\n\n    function renounceOwnership() override public virtual onlyOwner {\n        revert(\"Owner cannot renounce ownership\");\n    }\n}\n"
    },
    "contracts/openzeppelin/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"
    },
    "contracts/DAMM/Redemption.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../openzeppelin/Ownable.sol\";\nimport \"../openzeppelin/ERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\n\ncontract Redemption is Ownable, ReentrancyGuard {\n\n    event BdammRedemption(\n        address indexed from,\n        uint256 amount,\n        uint256 redemptionFee\n    );\n    event RedemptionUSDCPriceUpdated(\n        uint256 oldPrice,\n        uint256 newPrice\n    );\n\n    ERC20 BDAMM;\n    ERC20 DAMM;\n    ERC20 USDC;\n\n    address public treasury;\n    uint256 public redemptionUSDCPrice;\n    uint256 public totalRedemptions;\n    uint256 public totalUSDCFees;\n\n    constructor(\n        ERC20 addressBDAMM,      // 0xfa372fF1547fa1a283B5112a4685F1358CE5574d\n        ERC20 addressDAMM,       // 0xb3207935FF56120f3499e8aD08461Dd403bF16b8\n        ERC20 addressUSDC,       // 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n        address addressOwner,    // multisig address\n        address addressTreasury, \n        uint256 _redemptionUSDCPrice\n    ) {\n        BDAMM = addressBDAMM;\n        DAMM = addressDAMM;\n        USDC = addressUSDC;\n        Ownable._transferOwnership(addressOwner);\n        treasury = addressTreasury;\n        _updateRedemptionUSDCPrice(_redemptionUSDCPrice);\n    }\n\n    function _updateRedemptionUSDCPrice(uint256 _redemptionUSDCPrice) internal {\n        emit RedemptionUSDCPriceUpdated(redemptionUSDCPrice, _redemptionUSDCPrice);\n        redemptionUSDCPrice = _redemptionUSDCPrice;\n    }\n    /* \n      amount is the amount of BDAMM to swap to DAMM 1:1 (18 decimals)\n      redemptionFee is the amount of USDC to send with the redemption (6 decimals)\n    */\n    function redeem(uint256 amount, uint256 redemptionFee) nonReentrant external {\n        address user = msg.sender;\n        uint256 allowanceBDAMM = BDAMM.allowance(user, address(this));\n        require(amount <= allowanceBDAMM, \"User has not given swap contract spend approval for BDAMM\");\n        uint256 requiredRedemptionFee = amount * redemptionUSDCPrice;\n        require(redemptionFee * 1e18 == requiredRedemptionFee, \"Incorrect USDC redemption fee sent\");\n        uint256 allowanceUSDC = USDC.allowance(user, address(this));\n        require(redemptionFee <= allowanceUSDC, \"User has not given swap contract spend approval for USDC\");\n        uint256 selfBalanceDAMM = DAMM.balanceOf(address(this));\n        require(amount <= selfBalanceDAMM, \"Not enough DAMM liquidity\");\n        totalUSDCFees += redemptionFee;\n        totalRedemptions += amount;\n        emit BdammRedemption(user, amount, redemptionFee);\n        require(BDAMM.transferFrom(user, treasury, amount), \"Could not transfer user's BDAMM to treasury\");\n        require(USDC.transferFrom(user, treasury, redemptionFee), \"Could not transfer user's USDC to treasury\");\n        require(DAMM.transfer(user, amount), \"Swap contract could not transfer DAMM to user\");\n    }\n\n    function withdrawDAMM() onlyOwner external {\n        uint256 balance = DAMM.balanceOf(address(this));\n        require(DAMM.transfer(this.owner(), balance), \"Admin could not withdraw DAMM\");\n    }\n\n    function sweepToken(ERC20 token) onlyOwner external {\n      uint256 balance = token.balanceOf(address(this));\n      require(token.transfer(this.owner(), balance), \"Admin could not withdraw token\");\n    }\n\n    function updateRedemptionUSDCPrice(uint256 _redemptionUSDCPrice) onlyOwner external {\n      _updateRedemptionUSDCPrice(_redemptionUSDCPrice);\n    }\n\n    function renounceOwnership() override public virtual onlyOwner {\n        revert(\"Owner cannot renounce ownership\");\n    }\n\n    function transferOwnership(address newOwner) override public virtual onlyOwner {\n        // unused:\n        newOwner;\n        revert(\"Owner cannot transfer ownership\");\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 250
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}